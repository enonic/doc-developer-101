= Input types
include::variables.adoc[]
:project-name: animals
:project-name-full: {project-name-prefix}{project-name}

In the previous {document}, we created a very simple content type and used it to create some content. However, in real world settings, you're likely to going to want to use more complex content types with different kinds of data (such as images). In this {document}  we'll be looking at some of the basic input types that come with XP and what we use them for.

At the end of the {document}, we'll put everything we've learned so far together.

== Input types overview

XP provides a number of input types for you to work with. This section highlights a few types you'll be using a lot and shows off some of their special features and then mentions some of the types you're also likely to be seeing a lot of. Go to the reference docs for https://developer.enonic.com/docs/xp/stable/cms/input-types[a full list of all input types and their features].

=== TextLine

image::input-type-text-line.png[TextLine: A single-line input field., width=800]

TextLine inputs are useful for short fields that contain text. They're also the only input type that has built-in validation. TextLine inputs support two forms of validation: max length and regular expressions. They can be used separately or together. The max length validation specifies that a user's input can not be longer than the specified value. The regular expression validation allows you to provide a custom regex that is used to validate the input field as you wish.

NOTE: XP uses JavaScript's regex engine to validate the input. For more information on what kind of of patterns it recognizes, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#writing_a_regular_expression_pattern[MDN's documentation].

For example, an input that only allows between characters from `a` to `z` and requires between one and seventeen characters could look like this:

.A TextLine input type with
[source,xml]
----
<input name="validation-example" type="TextLine">
  <label>TextLine input validation example.</label>
    <config>
      <max-length>17<max-length>
      <regexp>^[a-fA-Z]+$</regexp>
    </config>
</input>
----

Further, if you want to provide a default value for a TextLine input, you can do that by using the `default` configuration option. For an example of how to do this and for more information on the TextLine input, visit the https://developer.enonic.com/docs/xp/stable/cms/input-types#textline[reference docs].

=== ImageSelector

image::input-type-image-selector.png[ImageSelector: An interactive image selection tool., width=800]

Images are a key part of many web experiences: they add color, break up the content, and gives the reader something to rest their eyes on. XP's image selector allows you to select an image for a piece of content and also to upload new images.

In XP, image selectors are great for when you want to associate one or more images with piece of content. For instance, if you're creating an animal data set, you might want to have an image of what each animal looks like both as a young and as an adult.

.An minimal ImageSelector configuration
[source,xml]
----
<input name="myimage" type="ImageSelector">
  <label>My Image</label>
</input>
----

Read more about the https://developer.enonic.com/docs/xp/stable/cms/input-types#imageselector[configuration of image selectors] in the reference docs.

=== Content Selector

image::input-type-content-selector.png[ContentSelector: An interactive content selection tool., width=800]

The image selector we just saw is actually a specialized form of the more complex ContentSelector input type. The ContentSelector input type allows you to reference other content. Let's say you have two content types: one of type person and one of type food. If you want to be able to specify which dishes the person likes, you could use a content type to create a reference from the person to their favored dish.

Because referencing other content types comes with a lot of variability, the ContentSelector type has configuration options to support this. You can choose to allow only certain content types or only content that's available at a certain path. You can also change how the selector is presented to the user, including how it should present available content to the user and whether it should list content status.

https://developer.enonic.com/docs/xp/stable/cms/input-types#contentselector[The full list of ContentSelector configuration options] is available in the reference docs, including a number of examples to explain content inclusion and exclusion. However, a simple configuration could look like this:

.A basic ContentSelector configuration that only allows one content type
[source, xml]
----
<input name="mycontentselector" type="ContentSelector">
  <label>My ContentSelector</label>
  <config>
    <allowContentType>citation</allowContentType>
  </config>
</input>
----

=== More useful input types

Some other very useful input types that it's worth looking into are:

https://developer.enonic.com/docs/xp/stable/cms/input-types#checkbox[CheckBox]:: A trusty input checkbox. Indicates whether something is in one of two states.
https://developer.enonic.com/docs/xp/stable/cms/input-types#combobox[ComboBox]:: A dropdown menu containing predefined options for the user to select from. Allows selection of one or more options.
https://developer.enonic.com/docs/xp/stable/cms/input-types#date[Date] and https://developer.enonic.com/docs/xp/stable/cms/input-types#datetime[DateTime]:: Provides an interactive date picker (with a time component in DateTime's case) to save date and times.
https://developer.enonic.com/docs/xp/stable/cms/input-types#geopoint[GeoPoint]:: Stores GPS coordinates.
https://developer.enonic.com/docs/xp/stable/cms/input-types#htmlarea[HtmlArea]:: Provides a rich text, multi-line input. We'll discuss this in detail in xref:rich-text[the next {document}].
https://developer.enonic.com/docs/xp/stable/cms/input-types#textarea[TextArea]:: Provides a multi-line text input with optional max length.

== Input type configuration

In the work we did in the previous {document}, we did some very minor configuration of the input types. In the sections above, we have seen a little more of what you can do, such as adding validation and specifying what formatting features the user should get.

All input types share the same configuration options. In the XML schema, these configuration options go directly under the `input` tag. Additionally, the `config` tag can hold input-specific configuration.

These full list of available configuration options is:

`label` (required):: What the input should be labeled as in the content form.
`occurrences` (optional):: Specifies whether this input is required to be filled out, and whether it's a list or not.
`default` (optional):: Gives a default value to the input.
`help-text` (optional):: Lets you specify a description of the input field to show to the user.
`config` (optional):: Input type-specific configuration.
+
Each input type also takes an optional `config` element for extra configuration. Because the input types are so different to each other, they all support different options. This is what allows us to use regex validation for TextLine inputs, configure formatting options for HtmlAreas, and what numeric values a Long or a Double input accepts.
+
To find out exactly what configuration options an input type accepts and how to configure it, visit https://developer.enonic.com/docs/xp/stable/cms/input-types[the input types documentation].

All of these configuration options are described in more detail in the https://developer.enonic.com/docs/xp/stable/cms/schemas#input_types[input types schema documentation], so head over there for more information and explanation of how the various inputs work. As a bonus,

=== Validation

Enonic also provides XML Schema Definitions (XSDs) for text editor integration and validation of your XML schemas. To use it, add the attribute `xmlns`, `xmlns:xsi`, and `xsi:schemaLocation` to your content-type as shown below:

.Using XSDs for schema validation of a content type definition.
[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<content-type
    xmlns="urn:enonic:xp:model:1.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="urn:enonic:xp:model:1.0 https://raw.githubusercontent.com/enonic/xp/master/modules/core/core-api/src/main/resources/META-INF/xsd/model.xsd">
  <display-name>person</display-name>
  <!-- rest of content elided for brevity -->
</content-type>
----

Note that in-editor schema validation depends on whether your text editor supports validating against XSD schemas or not.

== Task: Create an {project-name} data set

Time for a little recap! We'll put together everything we've learned about content types and input types thus far to create a new data set. A solution is listed below, but try and see if you can solve it yourself first. If you're wondering how to achieve some of the goals, try consulting the documentation that's been linked to in this {document}.

Your task is to create a new content type: "Animal" and to update the "Person" content type with new constraints and fields.

An animal should have the following inputs:

. Its name, e.g. "elephant". Each animal must have at least one name, but multiple are also okay. For instance, the reindeer is also known as caribou.
. A multi-line text input for adding a description of the animal. It should allow at most 500 characters.
. An image selector that accepts between 0 and 3 images.
. Help text where you think it would be helpful.

When you've created the content type, create a new folder in Content Studio at next to the people folder. Call it "animals".

For the person content type, here's what's going to change:

. Allow each person to have any number of aliases. (Hint: use the occurrences element; check the documentation for how it works.)
. Add a ContentSelector input that allows only content of the "Animal" type and that must be nested under the site's "animals" folder. Call it `favoriteAnimal`.
. Make the "name" field required.
. Use `display-name-expression` so that a person's display name is "{Real name} ({alias})", e.g. "Alecia Beth Moore (P!nk)". We haven't looked at this element previously, but as the https://developer.enonic.com/docs/xp/stable/cms/content-types#display_name_expressions[`display-name-expression` documentation] explains, it's a way to auto-generate the content display name based on values from the content type form fields.
(What happens if you add multiple aliases to a single person? What about none?)

To verify that everything works, create some animals, and try creating a content link between

=== Solution

We'll start by creating the application. We'll use the CLI for this and follow the same steps as we did in the previous {document}: follow the steps in the xref:content#_projects_and_starters[projects and starters section], but use {project-name-full} for the project name.

Next, we'll create the animal content type. In `src/main/resources/site/content-types/animal/animal.xml`, place the following content:

.The animal content type
[source,xml]
----
include::input_types_task.xml[]
----

<1>  This display name expression specifies that we want the content we create to have the same display name as whatever we put in the "name" input field.
<2> This help text explains what we want in the "name" field, in case the user wants more information.
<3> As mentioned in the task text, we don't want the user to be able add images to the "description" field.
<4> Using the `occurrences` element, we specify that the user can supply between zero and three images.

Because we'll have two applications using the same starter in our sandbox now, make sure you go and update the display name of the {project-name} project as described in xref:content#_changing_the_name_of_the_application[the section on changing your application's display name] from the previous {document}.

Now build and deploy your project to your sandbox as described in xref:content#_building_and_deploying[the building and deploying section], and create a new site at the root of the Content Studio hierarchy (see xref:content#_creating_a_site[the section on creating content in content studio for a refresher]).

Now create a piece of content that lives under the site and verify that the display name updates when you change the name field and that you can upload up to three images via the image selector.
