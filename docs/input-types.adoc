= Input types
include::variables.adoc[]

In the previous {document}, we created a very simple content type and used it to create some content. However, in real world settings, you're likely to going to want to use more complex content types with different kinds of data (such as images). In this {document}  we'll be looking at some of the basic input types that come with XP and what we use them for.

This {document} builds on what we did in the previous {document}, so if you haven't gone through that and want to follow along with the examples, you should go back ... // <- write more here

// maybe we create a new project here? to reduce the dependencies on previous {document}s

== Key input types

Depending on your use case, you'll probably end up using a variety of input types. However, here are some of the ones you'll probably encounter most often:

=== TextLine

image::input-type-text-line.png[TextLine: A single-line input field.]

When creating our "color" content type previously, we used an input of the _TextLine_ type. TextLine inputs are useful for short fields that contain text.

We used it for a hexadecimal values, but the format of the input was never enforced. However, we can improve on that. TextLine supports validation directly in the content type specification. We can provide both a max length for the input and a regular expression that it must match.

Let's say we only accept color values that consist of 6 characters (if you're familiar with hex color schemes, that means no shorthands and no alpha channel). If we include the leading `\#` in the input, that means it'll be a total of seven characters long. So for the validation, we can both set the max length to seven and use the regular expression `^#[a-fA-F\d]{6}$` for validation.

However, if you're familiar with regular expressions, you might have noticed that setting the max length when using the above regex doesn't really do anything because the regex is restrictive enough to specify both a minimum and a maximum length on its own, both seven. So we'll leave the max length out for now.

NOTE: XP uses JavaScript's regex engine to validate the input. For more information on what kind of of patterns it recognizes, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#writing_a_regular_expression_pattern[MDN's documentation].

Adding validation, the content type would look something like this:

.The Color content type with input validation
[source,xml]
----
<content-type>
  <display-name>Color</display-name>
  <super-type>base:structured</super-type>
  <form>
    <input name="hex" type="TextLine">
      <label>Hexadecimal representation</label>
      <config>
	<regexp>^#[a-fA-F\d]{6}$</regexp>
      </config>
    </input>
  </form>
</content-type>
----

Further, if you want to provide a default value for a TextLine input, you can do that by using the `default` configuration option. For an example of how to do this and for more information on the TextLine input, visit the https://developer.enonic.com/docs/xp/stable/cms/input-types#textline[reference docs].


=== HtmlArea

image::input-type-html-area.png[HtmlArea: A rich text input field with visible formatting options.]

While the TextLine input type is great for short inputs, it doesn't handle paragraphs of text very well, and it also doesn't provide any options for text formatting. For that, we have the HtmlArea.

The HtmlArea input type gives you a multi-line input field with rich formatting options, much like what you're used to from your favorite word processor. It supports text formatting and justification, lists, links, and even lets you insert images.

You can configure the HtmlArea to be exactly what you want by dictating what formatting tools to include or exclude (the `include` and `exclude` attributes, respectively), by what heading levels are allowed (`allowedHeadings`), and by giving it a default value (`default`).

To learn more about HtmlArea input type and how to configure all its options, check the https://developer.enonic.com/docs/xp/stable/cms/input-types#htmlarea[reference documentation for it]. A fully HtmlArea could look like this:

.An example HtmlArea input type
[source,xml]
----
<input name="myhtmlarea" type="HtmlArea">
  <label>My HtmlArea</label>
  <default><h3>Enter description here</h3></default>
  <config>
    <exclude>*</exclude>
    <include>JustifyLeft JustifyRight | Bold Italic</include>
    <allowHeadings>h2 h4 h6</allowHeadings>
  </config>
</input>
----

=== ImageSelector

image::input-type-image-selector.png[ImageSelector: An interactive image selection tool.]



=== Task: add these new input types to your content type

Let's explore these input types in practice. We'll add them to an existing content type and explore how they work.

== Additional input types

This section should briefly mention some less common input types, and refer the reader to https://developer.enonic.com/docs/xp/stable/cms/input-types[the reference docs].

Optionally, suggest that the reader go and add some of these too to see how they work.

== Input type configuration

When using the input types previously, we would have used labels. This section mentions other configuration options the `input` element accepts,  listed under https://developer.enonic.com/docs/xp/stable/cms/schemas#input_types[the input types section] of the doc on schemas.

Also mention that each input type accepts specialized, extra configuration under the `config` option, and that this configuration can be found in the same reference docs as before.

== Task: Create an animals API

Create a new site, animals, and use the input types we saw previously to create an animal content type. For instance: use a TextLine input for name, display-name-expression to reflect this to the display name, use a HtmlArea input for a description of the animal (get it from Wikipedia), and use the ImageSelector to upload an appropriate image.

== Mixins

We can use mixins to reuse input field sets across different content types!

=== Task

Create another content type that reuses a lot of the fields from our preexisting one. Solve it by using a Mixin.

=== Next / after mixins

// We might want to move this to the next section? Making it about input reuse and grouping / advanced content.

Mixins provide a handy way of reusing the same inputs across different content types. However, if you want to group a set of fields as a logical unit, you may be better off looking at item sets. Luckily, that's coming right up.
