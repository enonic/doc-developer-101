= Advanced content
include::variables.adoc[]
:x-data: notes
:x-data-capitalized: Notes

Over the previous two {document}s, we've looked at content types and input types. We've explored how to use and configure input types, but we've only seen input types as standalone components. What if we want to group or reuse a set of inputs across several content types? We'll be looking at that in this {document}.

However, before we get that far: now that our content types are getting more complex, wouldn't it be nice if we could validate them somehow?

== Content type validation

Enonic provides XML Schema Definitions (XSDs) for text editor integration and validation of your XML schemas. To use it, add the attribute `xmlns`, `xmlns:xsi`, and `xsi:schemaLocation` to your content types as shown below:

.Using XSDs for schema validation of a content type definition.
[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<content-type
    xmlns="urn:enonic:xp:model:1.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="urn:enonic:xp:model:1.0 https://raw.githubusercontent.com/enonic/xp/master/modules/core/core-api/src/main/resources/META-INF/xsd/model.xsd">
  <display-name>Content type display name</display-name>

  <!-- rest of content elided for brevity -->

</content-type>
----

Note that in-editor schema validation depends on whether your text editor supports validating against XSD schemas or not. If your editor doesn't support it out of the box, it may be available via a Language Server Protocol (LSP) client.

== Mixins

The first and simplest option for reuse is _mixins_. Mixins allow you to reuse fields across several content types. They won't look or behave any different from if you manually typed the same fields into multiple content types, but it lets you keep them in sync.  Mixins go in in the `/src/main/resources/site/mixins` directory, following the same naming pattern as the other schemas we've seen (`<mixin-name>/<mixin-name>.xml`).

To learn more about mixins, consult https://developer.enonic.com/docs/xp/stable/cms/mixins[the mixins reference documentation].

== X-data

X-data (short for _eXtra-data_) is a way for you to dynamically add extra data to some or all content types belonging to a site. In Content Studio, they'll be displayed as a separate field set below the content type's normal fields.

By configuring your application's `site.xml` (`src/main/resources/site/site.xml`) you can select which X-data schemas to add and to which content types, and whether to make the X-data optional or not. Go to the https://developer.enonic.com/docs/xp/stable/cms/x-data[X-data documentation] to read more about how.

As per usual, X-data schemas follow this naming and placement convention: `src/main/resources/site/x-data/<x-data-name>/<x-data-name>.xml`.

=== Task: add reference data

For the {content-type-2}s we've created thus far, we've brought in data and images from Wikipedia, but we haven't indicated this anywhere. If we wanted to indicate where we got some information from, we could do it using X-data. Your task is:

- Create a new X-data type. Call it {x-data}.
- It should have a single input field, "reference", that can have as many occurrences as the user wants
- Add the X-data to your site, but only to the `{content-type-2-capitalized}` content type.
- Try adding some references to one of your {content-type-2}s.

==== Solution

The X-data schema is very similar to the content type schemas we've worked with previously, so there's no real surprises here; just remember to wrap everything in an `x-data` tag:

.The {x-data} X-data schema
[source,xml,{subs}]
----
<x-data>
  <display-name>{x-data-Capitalized}</display-name>
  <form>
    <input type="TextLine" name="notes">
      <label>Notes</label>
      <occurrences minimum="0" maximum="0" />
    </input>
  </form>
</x-data>
----

Next, you need to reference the X-data in your `site.xml` and tell XP what content types it applies to. To do that, add an `x-data` tag in `site.xml` that has a `name` attribute that matches the name of your X-data ({x-data}). Make sure you add the `x-data` element before the `form` and `mappings` elements.

.The updated site.xml
[source,xml,{subs}]
----
<site>
  <x-data name="{x-data}" allowContentTypes="{project-name-full}:{content-type-2}"/> <--.-->
  <form/>
  <mappings>
    <mapping controller="/controllers/graphql.js" order="50">
      <pattern>/api</pattern>
    </mapping>
  </mappings>
</site>
----

<.> We use a regular expression to restrict which content types the X-data should apply to. In this case: only to `{content-type-2-capitalized}`

Now, if you open Content Studio, you should be able to add references to your {content-type-2-capitalized} content:

.Adding a reference
image::x-data-example.png["The content form for Lion with an additional 'References' section below the usual inputs. The first reference, a TextLine input, points to the Wikipedia article.'", width=600]


=== Headless: fetching X-data

When working headlessly, you can easily fetch X-data by querying for the `x` property of your content type. This query will fetch

.Querying for X-data
[source,GraphQL,{subs}]
----
{
  guillotine {
    query(contentTypes:"{project-name-full}:{content-type-2}",
      query: "displayName = 'Lion'") {
      ... on {project-name-query}_{content-type-2-Capitalized} {
        x {
          name
          data
        }
      }
    }
  }
}
----

So if you've added some references to your "Lion", you'll get something like this back:

.X-data results
[source,json]
----
{
  "data": {
    "guillotine": {
      "query": [
        {
          "x": [
            {
              "name": "com-example-myproject:notes",
              "data": "{references=Lion (Wikipedia): https://en.wikipedia.org/wiki/Lion}"
            }
          ]
        }
      ]
    }
  }
}
----

TODO: explain how to use the `x[].data` property?

== Item sets

Item sets also allow you to reuse fields across different content types, but more importantly, they allow you to group input types together in a logical fashion. This affects more than just the data models: item sets also get grouped together in content forms, providing a visual cue that certain fields pertain to the same topic. Item sets can also be arbitrarily nested.

The https://developer.enonic.com/docs/xp/stable/cms/sets#item_set[item set documentation] does a standout job of explaining exactly how they work (and what they look like), so check that out for an overview. https://developer.enonic.com/docs/xp/stable/cms/schemas#item_set[The item set schema documentation] contains all the information you'd need on how to create an item set schema.

=== Comparison to other data structures

If you're used to working with JSON data or similar data structures, you can think of item sets as JSON objects. They allow you to group a number of input types together into one unit (object). You can also nest them arbitrarily to create more complex structures.

=== Task: adding an item set to `{content-type-1-capitalized}`

Let's add an item set to the `{content-type-1-capitalized}`. All the people we entered back in xref:content#_add_some_friends[the content chapter] are successful musical artists, so we can create an item set for albums they have released.

To add an item set, use it as you would any other input type: place it within the `form` element of a content type. If we add it to the `{content-type-1-capitalized}` content type, it'd look something like this:

.{content-type-1-capitalized} with an added Item Set
[source,xml,{subs}]
----
<content-type>
  <display-name>person</display-name>
  <description>A description of a person</description>
  <super-type>base:structured</super-type>
  <form>

    <!-- Other fields elided for brevity -->

    <item-set name="albums">
      <label>Album</label>
      <occurrences minimum="0" maximum="0" />
      <items>
        <input name="Title" type="TextLine">
          <label>Title</label>
          <occurrences minimum="1" maximum="1" />
          </input>
          <input type="TextLine" name="releaseYear">
            <label>Release year</label>
          </input>
      </items>
    </item-set>

  </form>
</content-type>
----

Note that the remaining fields of the form have been left out in the above example.

With this new item set, we can add as many albums as we want:

image::item-set-album.png["An example of using the Album item set with two albums included.", width=800]


== Option sets

Option sets enable editors (working in Content Studio) to choose from a set of predefined options. This is similar to the ComboBox element, but option sets also allow options to carry extra data.

To illustrate this, let's take the item set task we just did. We could (and will in the next task) expand this list to also include singles and film appearances. To do that, each entry could be one of album, single, or film appearance. Depending on the kind of entry, it would also have different associated data. For instance, a film might also note the role played.

Option sets where users can select only one of a number of options are known as _single-select_ option sets. You can also use a _multi-select_ option set if the user should be able to select multiple options simultaneously. We'll look at this too in a task below.

The https://developer.enonic.com/docs/xp/stable/cms/sets#option_set[option set reference documentation] provides a good overview (with accompanying pictures) of how option sets work. Additionally, https://developer.enonic.com/docs/xp/stable/cms/schemas#option_set[the option set schema overview] is very thorough and full of examples on how to use the various configuration options.

=== Task: extend album list for {content-type-1}s

=== Task: add habitat data to {content-type-2}s

In this section, we'll use option sets to add some extra data to our `{content-type-2-capitalized}` data type. Our goal is:

- Add an option for habitat. The user should be able to select as many as they want from the 7 continents to indicate where the animal lives. Each option should have an associated TextArea called "notes", where the user can add more data for each option.

As before, we use option sets as we would any other input type:

.The `{content-type-2-capitalized}` content type with new option sets
[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<content-type>
  <display-name>Animal</display-name>
  <description>An animal that lives on planet Earth</description>
  <super-type>base:structured</super-type>
  <form>
    <!-- other fields elided for brevity -->

    <option-set name="feedingBehavior">
      <label>Feeding behavior</label>
      <options minimum="1" maximum="1"> <!--1-->
            <option name="herbivore"> <!--2-->
              <label>Herbivore</label>
            </option>

            <option name="carnivore"> <!--3-->
              <label>Carnivore</label>
              <items>
                  <input name="prey" type="TextLine">
                    <label>prey</label>
                    <occurrences minimum="0" maximum="0" />
                  </input>
                </items>
            </option>
        </options>
    </option-set>

    <option-set name="continents">
      <label>Habitat (continent)</label>
      <help-text>Continents where the animal can be found in the wild</help-text>
      <options minimum="0" maximum="0"> <!--4-->
        <option name="africa"> <label>Africa</label> </option>
        <option name="antarctica"> <label>Antarctica</label> </option>
        <option name="asia"> <label>Asia</label> </option>
        <option name="australia"> <label>Australia</label> </option>
        <option name="europe"> <label>Europe</label> </option>
        <option name="northAmerica"> <label>North America</label> </option>
        <option name="southAmerica"> <label>South America</label> </option>
      </options>
    </option-set>

  </form>
</content-type>
----

<1> This specifies that if you add feeding behavior, you must select one of the options, and you can not select more than one.
<2> The herbivore option has no associated data, so it consists solely of a label.
<3> The carnivore option allows you to optionally specify prey for the animal.
<4> This specifies that you can add as many habitats as you want.

Filling this out, it could look like this (with data appropriate for reindeer):

.Habitat and feeding behavior for reindeer
image::option-sets.png["Diet and habitat data filled out for reindeer", width=800]

Or like this (with data appropriate for lions):

.Habitat and feeding behavior for lions
image::option-sets-lion.png["Diet and habitat data filled out for lion", width=800]

== Next

In the next {document}, we'll take a break from looking at content types and input types, and have a brief look at using GraphQL for queries.
