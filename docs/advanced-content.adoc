= Advanced content
include::variables.adoc[]
:mixin: creatureDescriptor

Over the previous two {document}s, we've looked at content types and input types. We've explored how to use and configure input types, but we've only seen input types as standalone components. What if we want to group or reuse a set of inputs across several content types? We'll be looking at that in this {document}.

However, before we get that far: now that our content types are getting more complex, wouldn't it be nice if we could validate them somehow?

== Content type validation

Enonic provides XML Schema Definitions (XSDs) for text editor integration and validation of your XML schemas. To use it, add the attribute `xmlns`, `xmlns:xsi`, and `xsi:schemaLocation` to your content types as shown below:

.Using XSDs for schema validation of a content type definition.
[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<content-type
    xmlns="urn:enonic:xp:model:1.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="urn:enonic:xp:model:1.0 https://raw.githubusercontent.com/enonic/xp/master/modules/core/core-api/src/main/resources/META-INF/xsd/model.xsd">
  <display-name>Content type display name</display-name>

  <!-- rest of content elided for brevity -->

</content-type>
----

Note that in-editor schema validation depends on whether your text editor supports validating against XSD schemas or not. If your editor doesn't support it out of the box, it may be available via a Language Server Protocol (LSP) client.

== Mixins

The first and simplest option for reuse is _mixins_ (https://developer.enonic.com/docs/xp/stable/cms/mixins[mixins reference documentation]). Mixins allow you to reuse fields across several content types. They won't look or behave any different from if you manually typed the same fields into multiple content types, but it lets you keep them in sync. To demonstrate this, we'll create a `{content-type-3-capitalized}` content type that shares most of its configuration with the `{content-type-2-capitalized}` content type, but which also adds some extra fields.

We'll want to reuse the `name` and `description` fields from animal, but a `{content-type-3-capitalized}` should also have a list of sources it appears in, such as mythology or stories. We'll start by extracting the `name` and `description` fields into a mixin.

Mixins go in in the `/src/main/resources/site/mixins` directory, following the same naming pattern as the other schemas we've seen. Let's create a `{mixin}` mixin.

Save this file in `/src/main/resources/site/mixins/{mixin}/{mixin}.xml`:

[src, xml, subs={subs}]
----
<mixin>
  <display-name>Creature descriptor</display-name>
  <form>
    <input name="name" type="TextLine">
      <label>Name</label>
      <help-text>Put the names of the creature here. You can be as
      specific or as vague as you like.
      </help-text>
      <occurrences minimum="1" maximum="0"></occurrences>
    </input>

    <input name="description" type="HtmlArea" >
      <label>Description</label>
      <help-text>Describe the creature. Where its habitats are, what it
      eats, etc.</help-text>
      <config>
        <exclude>*</exclude>
        <include>Format Macro Image</include>
      </config>
    </input>
  </form>
</mixin>
----

We can then update the `{content-type-2-capitalized}` to use this mixin instead. Now it'll look a little something like this:o

.The `{content-type-2-capitalized}` content type using a mixin
[src,xml,subs={subs}]
----
<content-type>
  <display-name>Animal</display-name>
  <description>An animal that lives on planet Earth</description>
  <super-type>base:structured</super-type>
  <form>

    <mixin name="creatureDescriptor"/>

  </form>
</content-type>
----

.The `{content-type-3-capitalized}` content type
[source,xml,subs={subs}]
----
<content-type>
  <display-name>Legendary Creature</display-name>
  <description>A mythological creature</description>
  <display-name-expression>${name}</display-name-expression>
  <super-type>base:structured</super-type>
  <form>

    <mixin name="creatureDescriptor"/>

    <input type="TextLine" name="appearsIn">
      <label>Appears in:</label>
      <occurrences minimum="0" maximum="0" />
    </input>
  </form>
</content-type>
----

Mixins provide a handy way of reusing the same inputs across different content types. However, if you want to group a set of fields as a logical unit, you may be better off looking at item sets. Luckily, that's coming right up.


== Item sets

Item sets also allow you to reuse fields across different content types, but more importantly, they allow you to group input types together in a logical fashion. This affects more than just the data models: item sets also get grouped together in content forms, providing a visual cue that certain fields pertain to the same topic. Item sets can also be arbitrarily nested.

The https://developer.enonic.com/docs/xp/stable/cms/sets#item_set[item set documentation] does a standout job of explaining exactly how they work (and what they look like), so check that out for an overview. https://developer.enonic.com/docs/xp/stable/cms/schemas#item_set[The item set schema documentation] contains all the information you'd need on how to create an item set schema.

=== Comparison to other data structures

If you're used to working with JSON data or similar data structures, you can think of item sets as JSON objects. They allow you to group a number of input types together into one unit (object). You can also nest them arbitrarily to create more complex structures.

=== Task: adding an item set to `{content-type-1-capitalized}`

Let's add an item set to the `{content-type-1-capitalized}`. All the people we entered back in xref:content#_add_some_friends[the content chapter] are successful musical artists, so we can create an item set for albums they have released.

To add an item set, use it as you would any other input type: place it within the `form` element of a content type. If we add it to the `{content-type-1-capitalized}` content type, it'd look something like this:

.{content-type-1-capitalized} with an added Item Set
[source,xml,subs={subs}]
----
<content-type>
  <display-name>person</display-name>
  <description>A description of a person</description>
  <super-type>base:structured</super-type>
  <form>

    <!-- Other fields elided for brevity -->

    <item-set name="albums">
      <label>Album</label>
      <occurrences minimum="0" maximum="0" />
      <items>
        <input name="Title" type="TextLine">
          <label>Title</label>
          <occurrences minimum="1" maximum="1" />
          </input>
          <input type="TextLine" name="releaseYear">
            <label>Release year</label>
          </input>
      </items>
    </item-set>

  </form>
</content-type>
----

Note that the remaining fields of the form have been left out in the above example.

With this new item set, we can add as many albums as we want:

image::item-set-album.png["An example of using the Album item set with two albums included.", width=800]


== Option sets

Option sets enable editors (working in Content Studio) to choose from a set of predefined options. While this might sound similar to the ComboBox element, option sets also come with the option of attaching other input types (arbitrarily nested data) to each choice. Option sets can be either single-select or multi-select variants.

The https://developer.enonic.com/docs/xp/stable/cms/sets#option_set[option set reference documentation] provides a good overview (with accompanying pictures) of how option sets work. Additionally, https://developer.enonic.com/docs/xp/stable/cms/schemas#option_set[the option set schema overview] is very thorough and full of examples on how to use the various configuration options.


=== Comparison to other data structures

As their name would imply, option sets are basically sets of option. For each entry, you can choose whether to include it or not. Depending on the number of options you can choose (single-select vs multi-select), option sets work a little differently. Single-select option sets, work the same as union types or enums in a number of programming languages: you can pick one, and each option can have it's separate piece of associated data. Multi-selects essentially allow you to choose any combination of the options. (For those of you into combinatorics, that means we can get up to 2^n^ (where n is the number of options) variations if you can choose as many options as you want ðŸ¤“)


=== Task: add habitat and dietary data to {content-type-2}s

In this section, we'll use option sets to add some extra data to our `{content-type-2-capitalized}` data type. Our goal is:

- Add an option set for feeding behavior. It should have two options
.. Herbivore, which has no associated data
.. Carnivore, which allows the user to add any number of prey
- Add an option for habitat. The user should be able to select as many as they want from the 7 continents to indicate where the animal lives.

As before, we use option sets as we would any other input type:

.The `{content-type-2-capitalized}` content type with new option sets
[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<content-type>
  <display-name>Animal</display-name>
  <description>An animal that lives on planet Earth</description>
  <super-type>base:structured</super-type>
  <form>
    <!-- other fields elided for brevity -->

    <option-set name="feedingBehavior">
      <label>Feeding behavior</label>
      <options minimum="1" maximum="1"> <!--1-->
            <option name="herbivore"> <!--2-->
              <label>Herbivore</label>
            </option>

            <option name="carnivore"> <!--3-->
              <label>Carnivore</label>
              <items>
                  <input name="prey" type="TextLine">
                    <label>prey</label>
                    <occurrences minimum="0" maximum="0" />
                  </input>
                </items>
            </option>
        </options>
    </option-set>

    <option-set name="continents">
      <label>Habitat (continent)</label>
      <help-text>Continents where the animal can be found in the wild</help-text>
      <options minimum="0" maximum="0"> <!--4-->
        <option name="africa"> <label>Africa</label> </option>
        <option name="antarctica"> <label>Antarctica</label> </option>
        <option name="asia"> <label>Asia</label> </option>
        <option name="australia"> <label>Australia</label> </option>
        <option name="europe"> <label>Europe</label> </option>
        <option name="northAmerica"> <label>North America</label> </option>
        <option name="southAmerica"> <label>South America</label> </option>
      </options>
    </option-set>

  </form>
</content-type>
----

<1> This specifies that if you add feeding behavior, you must select one of the options, and you can not select more than one.
<2> The herbivore option has no associated data, so it consists solely of a label.
<3> The carnivore option allows you to optionally specify prey for the animal.
<4> This specifies that you can add as many habitats as you want.

Filling this out, it could look like this (with data appropriate for reindeer):

.Habitat and feeding behavior for reindeer
image::option-sets.png["Diet and habitat data filled out for reindeer", width=800]

Or like this (with data appropriate for lions):

.Habitat and feeding behavior for lions
image::option-sets-lion.png["Diet and habitat data filled out for lion", width=800]

== Next

In the next {document}, we'll take a break from looking at content types and input types, and have a brief look at using GraphQL for queries.
