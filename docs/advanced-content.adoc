= {title-advanced-content}
include::variables.adoc[]
:x-data: notes
:x-data-capitalized: Notes

Over the previous two {document}s, we've looked at content types and input types. We've explored how to use and configure input types, but we've only seen input types as standalone components. What if we want to group or reuse a set of inputs across several content types? We'll be looking at that in this {document}.

However, before we get that far: now that our content types are getting more complex, wouldn't it be nice if we could validate them somehow?

NOTE: {see-prev-docs}

== Content type validation

Enonic provides XML Schema Definitions (XSDs) for text editor integration and validation of your XML schemas. To use it, add the attribute `xmlns`, `xmlns:xsi`, and `xsi:schemaLocation` to your content types as shown below:

.Using XSDs for schema validation of a content type definition.
[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<content-type
    xmlns="urn:enonic:xp:model:1.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="urn:enonic:xp:model:1.0 https://raw.githubusercontent.com/enonic/xp/master/modules/core/core-api/src/main/resources/META-INF/xsd/model.xsd">
  <display-name>Content type display name</display-name>

  <!-- rest of content elided for brevity -->

</content-type>
----

Note that in-editor schema validation depends on whether your text editor supports validating against XSD schemas or not. If your editor doesn't support it out of the box, it may be available via a Language Server Protocol (LSP) client.

== Mixins

The first and simplest option for reuse is _mixins_. Mixins allow you to reuse fields across several content types. They won't look or behave any different from if you manually typed the same fields into multiple content types, but it lets you keep them in sync.  Mixins go in in the `/src/main/resources/site/mixins` directory, following the same naming pattern as the other schemas we've seen (`<mixin-name>/<mixin-name>.xml`).

To learn more about mixins, consult https://developer.enonic.com/docs/xp/stable/cms/mixins[the mixins reference documentation].

== X-data

X-data (short for _eXtra-data_) is a way for you to dynamically add extra data to some or all content types belonging to a site. In Content Studio, they'll be displayed as a separate field set below the content type's normal fields.

By configuring your application's `site.xml` (`src/main/resources/site/site.xml`) you can select which X-data schemas to add and to which content types, and whether to make the X-data optional or not. Go to the https://developer.enonic.com/docs/xp/stable/cms/x-data[X-data documentation] to read more about how.

As per usual, X-data schemas follow this naming and placement convention: `src/main/resources/site/x-data/<x-data-name>/<x-data-name>.xml`.

=== Task: add reference data

For the {content-type-2}s we've created thus far, we've brought in data and images from Wikipedia, but we haven't indicated this anywhere. If we wanted to indicate where we got some information from, we could do it using X-data. Your task is:

- Create a new X-data type. Call it {x-data}.
- It should have a single input field, "reference", that can have as many occurrences as the user wants
- Add the X-data to your site, but only to the `{content-type-2-capitalized}` content type.
- Try adding some references to one of your {content-type-2}s.

==== Solution

The X-data schema is very similar to the content type schemas we've worked with previously, so there's no real surprises here; just remember to wrap everything in an `x-data` tag:

.The {x-data} X-data schema
[source,xml,{subs}]
----
<x-data>
  <display-name>{x-data-Capitalized}</display-name>
  <form>
    <input type="TextLine" name="notes">
      <label>Notes</label>
      <occurrences minimum="0" maximum="0" />
    </input>
  </form>
</x-data>
----

Next, you need to reference the X-data in your `site.xml` and tell XP what content types it applies to. To do that, add an `x-data` tag in `site.xml` that has a `name` attribute that matches the name of your X-data ({x-data}). Make sure you add the `x-data` element before the `form` and `mappings` elements.

.The updated site.xml
[source,xml,{subs}]
----
<site>
  <x-data name="{x-data}" allowContentTypes="{project-name-full}:{content-type-2}"/> <--.-->
  <form/>
  <mappings>
    <mapping controller="/controllers/graphql.js" order="50">
      <pattern>/api</pattern>
    </mapping>
  </mappings>
</site>
----

<.> We use a regular expression to restrict which content types the X-data should apply to. In this case: only to `{content-type-2-capitalized}`

Now, if you open Content Studio, you should be able to add references to your {content-type-2-capitalized} content:

.Adding a reference
image::x-data-example.png["The content form for Lion with an additional 'References' section below the usual inputs. The first reference, a TextLine input, points to the Wikipedia article.'", width=600]


=== Headless: fetching X-data

When working headlessly, you can easily fetch X-data by querying for the `x` property of your content type. This query will fetch

.Querying for X-data
[source,GraphQL,{subs}]
----
{
  guillotine {
    query(contentTypes:"{project-name-full}:{content-type-2}",
      query: "displayName = 'Lion'") {
      ... on {project-name-query}_{content-type-2-Capitalized} {
        x {
          name
          data
        }
      }
    }
  }
}
----

So if you've added some references to your "Lion", you'll get something like this back:

.X-data results
[source,json]
----
{
  "data": {
    "guillotine": {
      "query": [
        {
          "x": [
            {
              "name": "com-example-myproject:notes",
              "data": "{references=Lion (Wikipedia): https://en.wikipedia.org/wiki/Lion}"
            }
          ]
        }
      ]
    }
  }
}
----

TODO: explain how to use the `x[].data` property?

== Item sets

Item sets also allow you to reuse fields across different content types, but more importantly, they allow you to group input types together in a logical fashion. This affects more than just the data models: item sets also get grouped together in content forms, providing a visual cue that certain fields pertain to the same topic. Item sets can also be arbitrarily nested.

The https://developer.enonic.com/docs/xp/stable/cms/sets#item_set[item set documentation] does a standout job of explaining exactly how they work (and what they look like), so check that out for an overview. https://developer.enonic.com/docs/xp/stable/cms/schemas#item_set[The item set schema documentation] contains all the information you'd need on how to create an item set schema.

=== Comparison to other data structures

If you're used to working with JSON data or similar data structures, you can think of item sets as JSON objects. They allow you to group a number of input types together into one unit (object). You can also nest them arbitrarily to create more complex structures.

=== Task: adding an item set to `{content-type-1-capitalized}`

Let's add an item set to the `{content-type-1-capitalized}`. All the people we entered back in xref:content#_add_some_friends[the content chapter] are successful musical artists, so we can create an item set for albums they have released.

To add an item set, use it as you would any other input type: place it within the `form` element of a content type. If we add it to the `{content-type-1-capitalized}` content type, it'd look something like this:

.{content-type-1-capitalized} with an added Item Set
[source,xml,{subs}]
----
<content-type>
  <display-name>person</display-name>
  <description>A description of a person</description>
  <super-type>base:structured</super-type>
  <form>

    <!-- Other fields elided for brevity -->

    <item-set name="albums">
      <label>Album</label>
      <occurrences minimum="0" maximum="0" />
      <items>
        <input name="title" type="TextLine">
          <label>Title</label>
          <occurrences minimum="1" maximum="1" />
          </input>
          <input type="TextLine" name="releaseYear">
            <label>Release year</label>
          </input>
      </items>
    </item-set>

  </form>
</content-type>
----

Note that the remaining fields of the form have been left out in the above example.

With this new item set, we can add as many albums as we want:

image::item-set-album.png["An example of using the Album item set with two albums included.", width=800]

=== Headless: fetching item sets

Getting item sets via GraphQL is not much different than anything else we've seen:

.Fetching albums
[source,GraphQL,{subs}]
----
{
  guillotine {
    query(contentTypes:"{project-name-full}:{content-type-1}",
      query: "displayName = 'P!nk'") {
      ... on {project-name-query}_{content-type-1-capitalized} {
        data {
          albums {
            title
            releaseYear
          }
        }
      }
    }
  }
}
----

With some data added for P!nk, you'd get a result like this:

.Album data
[source,json]
----
{
  "data": {
    "guillotine": {
      "query": [
        {
          "data": {
            "albums": [
              {
                "title": "The Truth About Love",
                "releaseYear": "2012"
              },
              {
                "title": "Beautiful Trauma",
                "releaseYear": "2017"
              }
            ]
          }
        }
      ]
    }
  }
}
----


== Option sets

Option sets enable editors (working in Content Studio) to choose from a set of predefined options. This is similar to the ComboBox element, but option sets also allow options to carry extra data.

To illustrate this, let's take the item set task we just did. We could expand this list to also include film appearances. To do that, each entry could be either an album _or_ film appearance. Depending on the kind of entry, it would also have different associated data. While title and release year might be enough for an album, it might be useful to add a list of roles to film entries.

Option sets where users can select only one of a number of options are known as _single-select_ option sets. You can also use a _multi-select_ option set if the user should be able to select multiple options simultaneously. We'll look at this too in a task below.

The https://developer.enonic.com/docs/xp/stable/cms/sets#option_set[option set reference documentation] provides a good overview (with accompanying pictures) of how option sets work. Additionally, https://developer.enonic.com/docs/xp/stable/cms/schemas#option_set[the option set schema overview] is very thorough and full of examples on how to use the various configuration options.


=== Task: add distribution and dietary data to {content-type-2}s

In this section, we'll use option sets to add some extra data to our `{content-type-2-capitalized}` data type. Our goal is:

- Add an option for distribution across continents. The user should be able to select as many as they want from the 7 continents to indicate where the animal lives. Each option should have an associated TextArea called "notes", where the user can add more data for each option.
- Because each distribution option should have the same fields, create a mixin to reuse it.
- Add an option set for feeding behavior. Intentionally simplified, this option set should indicate whether the animal is a herbivore or a carnivore, and if it is a carnivore, it should also let the user add a list of prey.

Start by creating the mixin. Call it `distributionData` and place it in `src/main/resources/site/mixins/distributionData/distributionData.xml`. It only contains a text area:

.The `distributionData` mixin
[source,xml,{subs}]
----
<mixin>
  <display-name>Distribution data</display-name>
  <form>

    <input type="TextArea" name="notes">
      <label>Notes</label>
    </input>

  </form>
</mixin>
----

Moving onto our {content-type-2}s, add the new option sets. As before, we use option sets as we would any other input type.

.The `{content-type-2-capitalized}` content type with new option sets
[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<content-type>
  <display-name>Animal</display-name>
  <description>An animal that lives on planet Earth</description>
  <super-type>base:structured</super-type>
  <form>

    <!-- other fields elided for brevity -->

    <option-set name="feedingBehavior">
      <label>Feeding behavior</label>
      <options minimum="1" maximum="1"> <--.-->

        <option name="herbivore"> <--.-->
          <help-text>Subsists primarily on plant material.</help-text>
          <label>Herbivore</label>
        </option>

        <option name="carnivore"> <--.-->
          <label>Carnivore</label>
          <help-text>Subsists primarily on animal tissue and meat.</help-text>
          <items>
            <input name="prey" type="TextLine">
              <label>Prey</label>
              <occurrences minimum="0" maximum="0" />
            </input>
          </items>
        </option>

      </options>
    </option-set>

    <option-set name="distribution">
      <label>Distribution across continents</label>
      <help-text>Continents where the animal can be found in the wild</help-text>
      <options minimum="0" maximum="0"> <--.-->

        <option name="africa">
          <label>Africa</label>
          <items>
            <mixin name="distributionData" />
          </items>
        </option>

        <option name="antarctica">
          <label>Antarctica</label>
          <items>
            <mixin name="distributionData" />
          </items>
        </option>

        <option name="asia">
          <label>Asia</label>
          <items>
            <mixin name="distributionData" />
          </items>
        </option>

        <option name="australia">
          <label>Australia</label>
          <items>
            <mixin name="distributionData" />
          </items>
        </option>

        <option name="europe">
          <label>Europe</label>
          <items>
            <mixin name="distributionData" />
          </items>
        </option>

        <option name="northAmerica">
          <label>North America</label>
          <items>
            <mixin name="distributionData" />
          </items>
        </option>

        <option name="southAmerica">
          <label>South America</label>
          <items>
            <mixin name="distributionData" />
          </items>
        </option>

      </options>
    </option-set>

  </form>
</content-type>
----

<1> This specifies that if you add feeding behavior, you must select one of the options, and you can not select more than one.
<2> The herbivore option has no associated data, so it consists solely of a label.
<3> The carnivore option allows you to optionally specify prey for the animal.
<4> This specifies that you can add as many distributions as you want.

Notice that the use of the `mixin` helps us both reduce duplication and keep all options in sync. If we wanted to add more data, such as current population, we would only have to add it to the `mixin` to have it duplicate to all distributions.

Filling this out, it could look like this (with data appropriate for lion):

.Distribution and feeding behavior for Lion
image::option-sets.png["Diet and distribution data filled out for reindeer", width=800]

=== Headless: fetching option set data

When fetching option set data, you can get the list of currently selected items and each item separately.

.Querying for feeding behavior and distribution
[source,GraphQL,{subs}]
----
{
  guillotine {
    query(contentTypes:"{project-name-full}:{content-type-2}",
      query: "displayName = 'Lion'") {
      ... on {project-name-query}_{content-type-2-capitalized} {
        data {
          feedingBehavior {
            _selected <--.-->
            carnivore { <--.-->
              prey
            }
          }
          distribution {
            _selected
            africa {
              notes
            }
          }
        }
      }
    }
  }
}

----

<.> This provides data about what the {content-type-2}s selected feeding behavior is.
<.> This gives more data about a particular option

.Query result
[source,json]
----
{
  "data": {
    "guillotine": {
      "query": [
        {
          "data": {
            "feedingBehavior": {
              "_selected": "carnivore",
              "carnivore": {
                "prey": [
                  "Zebra",
                  "Giraffe"
                ]
              }
            },
            "distribution": {
              "_selected": [
                "africa",
                "asia"
              ],
              "africa": {
                "notes": "African lions live in scattered populations across Sub-Saharan Africa. The lion prefers grassy plains and savannahs, scrub bordering rivers and open woodlands with bushes. It is absent from rainforests and rarely enters closed forests."
              }
            }
          }
        }
      ]
    }
  }
}
----

=== Task (bonus): extend album list for {content-type-1}s

We can also arbitrarily nest item sets and option sets. As mentioned above, try to extend the album list for {content-type-1}s to also allow for films. How you do this is up to you, but there are two main approaches:

. Wrap two item sets in an option set: Create an option set at the top level and allow the user to select as many options as they want. The options could be "Filmography" and "Discography", where the former has an item set with film data as associated content, and the latter an item set with album data.

. Make each item in the item set an option set. Keep the item set as is, but make every entry be _either_ an album _or_ a film.

Which approach is best depends on your circumstances and personal preference. Solutions to both approaches are listed below.

.Wrapping item sets in an option set
[source,xml]
----
<option-set name="media">
      <label>Media appearances</label>
      <options minimum="0" maximum="0">

        <option name="discography">
          <label>Discography</label>
          <items>
            <item-set name="albums">
              <label>Album</label>
              <occurrences minimum="0" maximum="0" />
              <items>
                <input name="title" type="TextLine">
                  <label>Title</label>
                  <occurrences minimum="1" maximum="1" />
                </input>
                <input type="TextLine" name="releaseYear">
                  <label>Release year</label>
                </input>
              </items>
            </item-set>
          </items>
        </option>

        <option name="filmography">
          <label>Filmography</label>
          <items>
            <item-set name="films">
              <label>Film</label>
              <occurrences minimum="0" maximum="0" />
              <items>
                <input name="title" type="TextLine">
                  <label>Title</label>
                  <occurrences minimum="1" maximum="1" />
                </input>
                <input type="TextLine" name="role">
                  <label>Role</label>
                  <occurrences minimum="0" maximum="0" />
                </input>
              </items>
            </item-set>
          </items>
        </option>

      </options>
    </option-set>
----

.Each item can be either a film _or_ an album
[source,xml]
----
<item-set name="media">
      <label>Media</label>
      <items>
        <option-set name="kind">
          <label>Media type</label>
          <options minimum="1" maximum="1">

            <option name="album">
              <label>Album</label>
              <items>
                <input name="title" type="TextLine">
                  <label>Title</label>
                  <occurrences minimum="1" maximum="1" />
                </input>
                <input type="TextLine" name="releaseYear">
                  <label>Release year</label>
                </input>
              </items>
            </option>

            <option name="film">
              <label>Film</label>
              <items>
                <input type="TextLine" name="title">
                  <label>Title</label>
                </input>
                <input type="TextLine" name="roles">
                  <label>Role</label>
                  <occurrences minimum="0" maximum="0" />
                </input>
              </items>
            </option>

          </options>
        </option-set>
      </items>
    </item-set>
----

== Next

In the next {document}, we'll take a break from looking at content types and input types, and have a brief look at using GraphQL for queries.
