= Content and content types
include::variables.adoc[]

In this {document}, we'll start building on the app we deployed previously and use an automatically generated GraphQL API for the content we create. In doing this, we'll learn about _content types_ and how to do basic work with  Content Studio.

NOTE: This {document} builds on the steps we took in the xref:basics[previous {document}], so if you haven't already done it, make sure you go through it and get everything ready. When you're sure you're up to speed with the previous {document}, let's get get started!

== What are content types?

Content types are schemas that tell XP what properties a piece of content of a particular type can have. That might sound confusing, but imagine for a second that we're working with forms. Content types describe what fields go in a specific form. Then a piece of content is a form that has been filled out. We'll look at an example to make this even clearer.

Imagine we want our app to list people. We'll create a simple representation of a {content-type-1}: we're only interested in their name and an optional alias, nickname, or pseudonym. Here's what a {content-type-1} content type could look like. The most relevant parts are numbered and further explained below.

==== Comparison of content types to other schema descriptions

If you're used to working with databases, you can think of content types as table schemas and contents as the rows of a table. The properties are the columns specified by the schema.

Similarly, a content type is much like a _(data) type_ or a _class_ in many programming languages: something that describes the shape of your data. A piece of content is a manifestation/instance of that data type. The properties of the content type specify what that data type contains.

== My first content type

We've created our first app, but an app isn't terribly exciting if it doesn't have any content to deliver. While content _creation_ takes place inside Content Studio, Content Studio first needs to know something about what kinds of content the end user can create. Enter: _content types_.

.A simple content type describing the '{content-type-1}' content type
[source,xml,subs={subs}]
----
<?xml version="1.0" encoding="utf-8"?>
<content-type>
  <display-name>{content-type-1-capitalized}</display-name> <!--1-->
  <description>A description of a {content-type-1}</description> <!--2-->
  <super-type>base:structured</super-type>
  <form> <!--3-->

    <input name="name" type="TextLine"> <!--4-->
      <label>Name</label>
    </input>

    <input name="alias" type="TextLine">
      <label>Alias</label>
    </input>

  </form>
</content-type>
----

<1> This is the name of the content type and is what will be displayed in Content Studio when you create a piece of content of this type.
<2> This is a short description of what the content type is. It's not strictly required, but it's highly recommended to add a description to all your content types.
<3> This is where we specify what properties this content type contains. The contents of this tag control what we see and are able to edit in Content Studio.
<4> This is a property of the content type. The `type` attribute specifies what kind of input field the user will see in Content Studio, and the `label` specifies how the input will be labeled.

NOTE: Content types also have a large number of other, optional fields that we won't get into here. If you'd like to learn more about this, consult https://developer.enonic.com/docs/xp/stable/cms/content-types[the reference documentation].

To create an instance of this content type, we could use Content Studio (we'll see exactly how to do this shortly!). Upon exposing it via an API, we would most likely see the piece of content exposed as JSON, so that's what we'll use to illustrate a piece of content.

For instance, if we created an entry for Belcalis Marlenis Almánzar, better known as Cardi B, then that instance of the {content-type-1} content type (that piece of content) would be represented in JSON as this:

.A piece of content of type '{content-type-1-capitalized}'
[source,json]
----
{
  "name": "Belcalis Marlenis Almánzar",
  "alias": "Cardi B"
}
----

So, to recap: _content types_ describe the shape of some data that's been grouped together. A piece of _content_ is the manifestation of that content type, populated with actual data. If it's still a bit fuzzy, don't worry! It'll become clearer once we start working with it.

=== Creating a content type

Now that we know what a content type is, let's look at how we create them and make XP recognize them. We'll use the "{content-type-1-capitalized}" content type from before to keep things simple.

XP is quite particular about project folder structure, so we need to put content types right where it expects to find them. The location is under `src/main/resources/site/content-types`.

Within the `content-types` directory, we need to place another directory with the name of the content type (in our case: "{content-type-1-capitalized}"), and within that directory, we place our content type, `{content-type-1-capitalized}.xml`. As such, the full path to our content type from the project root is `src/main/resources/site/content-types/{content-type-1}/{content-type-1}.xml`.

Now, unless you've created it manually, then that directory doesn't exist in our "{project-name}" project yet, so go ahead and create the required directories and files.

In the `{content-type-1}.xml` file, place the following contents:

.The {content-type-1-capitalized} content type
[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<content-type>
  <display-name>{content-type-1-capitalized}</display-name>
  <description>A description of a {content-type-1}</description>
  <super-type>base:structured</super-type>
  <form>

    <input name="name" type="TextLine">
      <label>Name</label>
    </input>

    <input name="alias" type="TextLine">
      <label>Alias</label>
    </input>

  </form>
</content-type>
----

Now run:

  enonic project deploy

If everything goes well, you should see your sandbox logs update now. And that's the basics of creating new content types. Next, let's turn our eyes to Content Studio and create some actual content!

== Content Creation 101

After the preceding few steps, everything is ready for us to create some actual content! So with your sandbox up and running, and navigate to {cs-url}[Content Studio]. You should be met with an empty studio that tells you you are "wasting this space":

.An empty content studio
image::content-studio-empty.png[What Content Studio looks like when it's completely empty.]

=== Creating a site

Before we can create our content, we need a _site_ to hold it. Sites are a special content type that ships with Content Studio. It's one of a very small number of content types that we can place at the very root of the content hierarchy. A site is like a root node that we can nest other content under. When we create a new site, we can also specify which applications it uses, and that's where our application comes into play.

To get going, press the "New..." button in the command bar or use the keyboard shortcut kbd:[Alt+n]. This will bring up a "Create Content" dialog that looks something like this:

.The Content Studio create content dialog
image::content-studio-create-content.png[The Content Studio create content dialog.]

Select "Site" either by clicking on it, or by navigating to it with your keyboard. You can start typing as soon as the dialog opens to filter the options too!

When you select it, your browser will take you to a new tab (or window, depending on your browser settings). This is the content creation form (or _wizard_).

.Creating a new site in Content Studio.
image::content-studio-new-site.png[Creating a new site in content studio. There is a form with site options on the left.]

Add the site name in the first field (with the `<Display Name>` placeholder). It's our first site, so let's go with "{p1-site-name}". Notice that when you do this, the path below the input field gets automatically updated to match what you input. You can manually override the path if you wish, but we'll leave it as is for now.

The description field is used to describe what the site is about. It's an optional field, so you can either leave it blank or add a description of your liking.

The next field, "Applications", is important. This is where we tell Content Studio what sort of applications the site uses and thus what content types we can create within it. Select the "Headless Starter" app.

Your site form should now look a little something like this.

.A filled out site creation form
image::content-studio-site-filled-out.png[What the site form looks like after filling out the necessary fields.]

To confirm and return to the Content Studio hierarchy, you can either press "Save" in the menu bar or use the keyboard shortcut: kbd:[ctrl+enter] on Linux and Windows and kbd:[⌘+enter] on macOS. The keyboard shortcut will also close the tab for you after saving. If you clicked the "Save" button in the menu, feel free to close the tab manually (you won't be needing it again).

When you return to the Content Studio hierarchy view, you should now see your site listed. If you expand it, you'll find that there is also a node called "Templates" underneath it. We can ignore this for now, but we'll learn more about it later.

=== Add some friends

With the "{p1-site-name}" site highlighted, press "New ..." (or kbd:[Alt+n]!) to open the "Create Content" menu again. This time around, you should have some more choices than what you did previously, including our very own content type "{content-type-1-capitalized}"!

.The "Create Content" dialog with more content types
image::content-studio-new-content.png["The \"Create Content\" dialog when creating content under the \"{p1-site-name}\" site. It contains more elements than previously, including the \"{content-type-1-capitalized}\" content type that we created earlier."]

However, before we start creating people, let's create a folder. Because we'll be using this site in the coming {document}s with more content types, having some hierarchy will make things easier. Choose a new folder and call it "people".

Next, let's create a few people to get used to the workflow. We'll start with Cardi B.

. Select the people folder (make sure it's highlighted).
. Create a new {content-type-1}.
. Give it the display name "Cardi B".
. Enter "Belcalis Marlenis Almánzar" in the "name" field and "Cardi B" in the "alias" field.

It should look a little something like this:

.The content form filled out for the {content-type-1} "Cardi B"
image::content-studio-new-{content-type-1}.png[The form for "{content-type-1}" fully filled out.]

Again, save and close the tab (kbd:[ctrl+enter]/kbd:[⌘+enter]). Now repeat this process for Melissa Arnette Elliott (better known as Missy Elliott) and Alecia Beth Moore (known professionally as P!nk). Be aware that Content Studio lets you nest content, so if you try and create new content when "Cardi B" is selected in the hierarchy, it'll nest the new content under "Cardi B". In our case, though, we want the people to be nested directly under the current folder, so make sure "people" folder is selected when you create new content.

With these people created, your content hierarchy should now list the site, the people folder, and the three people.

.The hierarchy as it should look after creating some content
image::content-studio-with-people.png["The content hierarchy showing the {p1-site-name} site with \"Cardi B\", \"Missy Elliot\", \"P!nk\", and \"Templates\" listed directly underneath it.", width=350]

== Querying the API

So we've created a custom content type and used it to create content, but what good is content if we can't access it from anywhere? Luckily, the headless starter kit has our backs! When using the headless starter kit, we get a GraphQL API automatically generated without any additional work.

NOTE: GraphQL is a graph "query language". It allows you to create highly specific queries for exactly the content that you need.

The headless starter uses an XP library called https://market.enonic.com/vendors/enonic/guillotine-headless-lib[Guillotine] to dynamically expose all our editorial content. We'll learn more about how this works later, but for now (with the default configuration) we can find the API at {p1-api-url}.

NOTE: If you have used a different name than "{p1-site-name}" for your site, you'll have to modify the URL a little: Switch `{p1-site-path}` for the path of your site.

After navigating to {p1-api-url}, you'll find the _GraphQL playground_ waiting for you. The GraphQL playground is an interactive API explorer for GraphQL APIs. You enter your query in the text area to your left and when you execute it, you'll get the results of the query on the other side of the screen.

.The GraphQL playground
image::graphql-playground-empty.png[An empty GraphQL playground]

In this {document}, we'll only barely dip our toes into the waters of GraphQL. We'll explore this further in a xref:headless-api[later chapter], but if you're interested, you can always check out the https://graphql.org/learn/[GraphQL docs].

To see what GraphQL can do for us, let's see if we can just fetch all the people that we created. Copy the below query into your playground and run it by pressing kbd:[ctrl+enter]/kbd:[⌘+enter] or by clicking the play button.

.A GraphQL query fetching all content below the "{p1-site-name}" site
[source,GraphQL,subs={subs}"]
----
{
  guillotine {
    getChildren(key: "{p1-site-path}/people")
    {
      displayName
    }
  }
}
----

The result of this query should list all the people you created previously as well as the Templates directory that came with the site:

.The result of the above query; all content nodes below "people"
[source,JSON]
----
{
  "data": {
    "guillotine": {
      "getChildren": [
        {
          "displayName": "P!nk"
        },
        {
          "displayName": "Missy Elliott"
        },
        {
          "displayName": "Cardi B"
        }
      ]
    }
  }
}
----

Neat! Next, let's try a slightly more complicated query. In this one,  we'll also get the data inside the content nodes and extract their names and alias fields.

.A GraphQL query that fetches all people and their data
[source, GraphQL,subs={subs}]
----
{
  guillotine {
    getChildren(key: "{p1-site-path}/people/")
    {
      displayName
      ... on com_example_myproject_{content-type-Capitalized} {
        data {
          name
          alias
        }
      }
    }
  }
}
----

Exeprimary-cute this and your response should look a little something like this:

.People and their aliases as returned by GraphQL
[source,JSON]
----
{
  "data": {
    "guillotine": {
      "getChildren": [
        {
          "displayName": "P!nk",
          "data": {
            "name": "Alecia Beth Moore",
            "alias": "P!nk"
          }
        },
        {
          "displayName": "Missy Elliott",
          "data": {
            "name": "Melissa Arnette Elliott",
            "alias": "Missy Elliott"
          }
        },
        {
          "displayName": "Cardi B",
          "data": {
            "name": "Belcalis Marlenis Almánzar",
            "alias": "Cardi B"
          }
        }
      ]
    }
  }
}
----

== Publishing and branches


== Summary

Whew; we've been through a lot in this {document}! We've created our first XP app, looked at creating content types, had a look at Content Studio and even got to play around with GraphQL a little.

For now, this has given us a first glimpse into how easy it can be to get started with building a headless API on XP.

== Next

Next we'll focus a little more on input types. The content types we created in this {document} were exceedingly simple. What if you want to create something more complex? Chances are XP has got just what you need, and if it doesn't, it provides you the tools to make what you need yourself!
