= {title-content}
include::variables.adoc[]
:about-cardi: Belcalis Marlenis Almánzar (born October 11, 1992), known professionally as Cardi B, is an American rapper and songwriter.
:about-missy: Melissa Arnette Elliott (born July 1, 1971) is an American rapper, singer, songwriter, and record producer.
:about-pink: Alecia Beth Moore (born September 8, 1979), known professionally as Pink (stylized as P!nk), is an American singer and songwriter.

In this {document}, we'll start building on the app we deployed previously and use an automatically generated GraphQL API for the content we create. In doing this, we'll learn about _content types_ and how to do basic work with  Content Studio.

NOTE: {see-prev-docs}

== What are content types?

Content types are schemas that tell XP what properties a piece of content of a particular type can have. Think of a piece of content as a collection of data. Its content type describes what data that piece of content can and must have.

If you're used to working with databases, you can think of content types as table schemas and contents as the rows of a table. The properties are the columns specified by the schema. Similarly, a content type is much like a _(data) type_ or a _class_ in many programming languages: something that describes the shape of your data. A piece of content is a manifestation/instance of that data type. The properties of the content type specify what that data type contains.

== Task: The {content-type-1} content type

Now that we know what a content type is, let's look at how we create them and make XP recognize them. By the end of this section we'll have created a content type that gives us a simple form that looks like this in Content Studio:

.The target for our first content type
image::content-type-target.png["A content creation form with name and biography fields", {image-xl}]

XP is quite particular about project folder structure, so we need to put content types right where it expects to find them. The location is under `src/main/resources/site/content-types`.

Within that directory, XP expects another folder with the name of the content type (`{content-type-1}`) which contains (at least) an XML schema called `{content-type-1}.xml`. The full path to our content type from the project root is `src/main/resources/site/content-types/{content-type-1}/{content-type-1}.xml`.

Now, unless you've created it manually, then that directory doesn't exist in our "{project-name}" project yet, so go ahead and create the required directories and files.

In the `{content-type-1}.xml` file, place the following contents:

.The '{content-type-1-capitalized}' content type
[source,xml,{subs}]
----
<content-type>
  <display-name>{content-type-1-capitalized}</display-name> <!--1-->
  <description>Information about an {content-type-1}</description> <!--2-->
  <super-type>base:structured</super-type>
  <form> <--3-->

    <input name="name" type="TextLine"> <--4-->
      <label>Name</label>
      <help-text>
        The artist's name (if different from their professional moniker).
      </help-text>
    </input>

    <input type="TextArea" name="about">
      <label>About the {content-type-1}</label>
    </input>

  </form>
</content-type>
----

<1> This is the name of the content type and is what will be displayed in Content Studio when you create a piece of content of this type.
<2> This is a short description of what the content type is. It's not strictly required, but it's highly recommended to add a description to all your content types.
<3> This is where we specify what properties this content type contains. The contents of this tag control what we see and are able to edit in Content Studio.
<4> This is a property of the content type. The `type` attribute specifies what kind of input field the user will see in Content Studio, and the `label` specifies how the input will be labeled.

NOTE: Content types also have a large number of other, optional fields that we won't get into here. If you'd like to learn more about this, consult https://developer.enonic.com/docs/xp/stable/cms/content-types[the reference documentation].

Now run:

  enonic project deploy

If everything goes well, you should see your sandbox logs update now. And that's the basics of creating new content types. Next, let's turn our eyes to Content Studio and create some actual content!

== Sites

After the preceding few steps, everything is ready for us to create some actual content! So with your sandbox up and running, and navigate to {cs-url}[Content Studio]. You should be met with an empty studio that tells you you are "wasting this space":

.An empty content studio
image::content-studio-empty.png[What Content Studio looks like when it's completely empty., {image-xl}]

=== Task: Creating a site

Before we can create our content, we need a _site_ to hold it. Sites are a special content type that ships with Content Studio. It's one of a very small number of content types that we can place at the very root of the content hierarchy. A site is like a root node that we can nest other content under. When we create a new site, we can also specify which applications it uses, and that's where our application comes into play.

To get going, press the "New..." button in the command bar. This will bring up a "Create Content" dialog that looks something like this:

TIP: You can also use the keyboard shortcut kbd:[Alt+n] to bring up the "Create Content" dialog.

.The Content Studio create content dialog
image::content-studio-create-content.png[The Content Studio create content dialog., {image-xl}]

Select "Site" either by clicking on it, or by navigating to it with your keyboard. You can start typing as soon as the dialog opens to filter the options too!

When you select it, your browser will take you to a new tab (or window, depending on your browser settings). This is the content creation form (or _wizard_).

.Creating a new site in Content Studio.
image::content-studio-new-site.png[Creating a new site in content studio. There is a form with site options on the left., {image-xl}]

Add the site name in the first field (with the `<Display Name>` placeholder). It's our first site, so let's go with "{p1-site-name}". Notice that when you do this, the path below the input field gets automatically updated to match what you input. You can manually override the path if you wish, but we'll leave it as is for now.

The description field is used to describe what the site is about. It's an optional field, so you can either leave it blank or add a description of your liking.

The next field, "Applications", is important. This is where we tell Content Studio what sort of applications the site uses and thus what content types we can create within it. Select the "Headless Starter" app.

Your site form should now look a little something like this.

.A filled out site creation form
image::content-studio-site-filled-out.png[What the site form looks like after filling out the necessary fields., {image-xl}]

To confirm and return to the Content Studio hierarchy, press "Save" in the menu bar. Feel free to close the tab (you won't be needing it again).

TIP: The keyboard shortcut: kbd:[ctrl+enter] on Linux and Windows and kbd:[⌘+enter] on macOS also saves the content for you. Additionally, the keyboard shortcut will also close the tab for you after saving.

When you return to the Content Studio hierarchy view, you should now see your site listed. If you expand it, you'll find that there is also a node called "Templates" underneath it. We can ignore this for now, but we'll learn more about it later.

== Task: Content creation

With the "{p1-site-name}" site highlighted, press "New ..." to open the "Create Content" menu again. This time around, you should have some more choices than what you did previously, including our very own content type "{content-type-1-capitalized}"!

.The "Create Content" dialog with more content types
image::content-studio-new-content.png["The \"Create Content\" dialog when creating content under the \"{p1-site-name}\" site. It contains more elements than previously, including the \"{content-type-1-capitalized}\" content type that we created earlier.", {image-xl}]

However, before we start creating {content-type-1}s, let's create a folder. Because we'll be using this site in the coming {document}s with more content types, having some hierarchy will make things easier. Choose a new folder and call it "{content-type-1}s".

Next, let's create a few {content-type-1}s to get used to the workflow. We'll start with Cardi B.

. Select the {content-type-1}s folder (make sure it's highlighted).
. Create a new {content-type-1}.
. Give it the display name "Cardi B".
. Use these details to fill in the form:
+
.Artist details (https://en.wikipedia.org/wiki/Cardi_B[Cardi B on Wikipedia])
Name:: Belcalis Marlenis Almánzar
About:: {about-cardi}

It should look a little something like this:

.The content form filled out for the {content-type-1} "Cardi B"
image::content-type-filled-out.png[The form for "{content-type-1}" fully filled out., {image-xl}]

Again, save and close the tab. Now repeat this process for these next two entries. Be aware that Content Studio lets you nest content, so if you try and create new content when "Cardi B" is selected in the hierarchy, it'll nest the new content under "Cardi B". In our case, though, we want the {content-type-1}s to be nested directly under the current folder, so make sure "{content-type-1}s" folder is selected when you create new content.

.Missy Elliott (https://en.wikipedia.org/wiki/Missy_Elliott[Missy Elliott on Wikipedia])
Name:: Melissa Arnette Elliott
About:: {about-missy}


.P!nk (https://en.wikipedia.org/wiki/Pink_(singer)[P!nk on Wikipedia])
Name:: Alecia Beth Moore
About:: {about-pink}

With these {content-type-1}s created, your content hierarchy should now list the site, the {content-type-1}s folder, and the three {content-type-1}s.

.The hierarchy as it should look after creating some content
image::content-studio-with-{content-type-1}s.png["The content hierarchy showing the {p1-site-name} site with \"Cardi B\", \"Missy Elliot\", \"P!nk\", and \"Templates\" listed directly underneath it.", {image-xl}]

== Branches and publishing

You might have noticed the yellow circles with exclamation marks displayed on all the content we've been working on, both in the wizard and in the content grid. This is how Content Studio indicates whether something is published or not and whether there are any errors with it. There are four states:

Error (red circle with a cross):: This indicates that there is something wrong with your content. Because XP uses structured content it can also validate content as it is created. If something doesn't conform to the specified schema (for example: a required field has no value), it will fail to validate and be marked with this symbol.
Work in progress (yellow circle with exclamation mark):: This symbol indicates that this piece of content has unpublished changes. That could be either because this is new content that has never been published, or it could be because there have been changes to this piece of content since it was last published.
Ready for publishing (green circle with a check mark):: This piece of content is marked as ready to be published.
Published (no icon):: This piece of content is published and has not been modified since.

.Content status symbols
image::content-studio-content-status.png[Three pieces of content displaying the three statuses that a piece of content can have, {image-m}]

So what does it mean for content to be published? It doesn't make much of a difference to us at this stage of the tutorial, but for when you're working on production systems, it's very important. So let's talk briefly about Content Studio's branching and publishing system.

Content Studio operates with two branches: a draft branch where you work and edit, and a branch that holds the published content, known as the master branch. When you work on something in Content Studio, you're working on the draft branch. When you publish something, the master branch gets updated with the new content. When you edit that same piece of content in Content Studio again, you're back to working on the draft, and you have to publish it to see changes to the published content.

To publish a piece of content, right click it and select "Publish".

TIP: You can also publish a piece of content by using the keyboard shortcut kbd:[ctrl+Alt+P]/kbd:[⌘+Alt+P].


=== Task: publish your site!

Let's give this publishing thing a try! We'll publish the whole site at once. Select your your site and publish it. You'll be greeted by the Content Studio publishing wizard.

.The Content Studio publishing wizard 🪄
image::content-studio-publishing-wizard.png[A dialog with a list of the content to be published and button saying 'publish now', {image-xl}]

You'll find that the "Publish now" button isn't available just yet. For content to be published, you must first _mark it as ready_. But before we do that, we should also make sure that we select all the content that belongs under the site too. By default, publishing a piece of content doesn't publish items nested under it. To include nested content, press the "include child items" icon to the left of the content icon (the one that looks sort of like a fork or a three-legged octopus). Next, select the "mark as ready" option from the button dropdown. It'll mark your content as ready to publish. Now press "publish now".

In short:

. Select your site. Publish.
. Include child items.
. Mark as ready.
. Publish 🚀

== Headless: Querying the API

So we've created a custom content type and used it to create content, but what good is content if we can't access it from anywhere? Luckily, the headless starter kit has our backs! When using the headless starter kit, we get a GraphQL API automatically generated without any additional work.

NOTE: GraphQL is a graph "query language". It allows you to create highly specific queries for exactly the content that you need.

The headless starter uses an XP library called https://market.enonic.com/vendors/enonic/guillotine-headless-lib[Guillotine] to dynamically expose all our editorial content. We'll learn more about how this works later, but for now (with the default configuration) we can find the API at {p1-api-url}.

NOTE: If you have used a different name than "{p1-site-name}" for your site, you'll have to modify the URL a little: Switch `{p1-site-path}` for the path of your site. See the Guillotine reference docs for an https://developer.enonic.com/docs/guillotine/stable/usage#context[explanation of how the URL is generated].

After navigating to the API, you'll find the _GraphQL playground_ waiting for you. The GraphQL playground is an interactive API explorer for GraphQL APIs. You enter your query in the text area to your left and when you execute it, you'll get the results of the query on the other side of the screen.

.The GraphQL playground
image::graphql-playground-empty.png[An empty GraphQL playground, {image-xl}]

In this {document}, we'll only barely dip our toes into the waters of GraphQL. We'll explore this further in the coming {document}s, but if you're interested, you can always check out the https://graphql.org/learn/[GraphQL docs].

To see what GraphQL can do for us, let's see if we can just fetch all the {content-type-1}s that we created. Copy the below query into your playground and run it by pressing kbd:[ctrl+enter]/kbd:[⌘+enter] or by clicking the play button.

.A GraphQL query fetching all content below the "{p1-site-name}" site
[source,GraphQL,{subs}"]
----
{
  guillotine {
    getChildren(key: "${site}/{content-type-1}s")
    {
      displayName
    }
  }
}
----

The result of this query should list all the {content-type-1}s you created previously as well as the Templates directory that came with the site:

.The result of the above query; all content nodes below "{content-type-1}s"
[source,JSON]
----
{
  "data": {
    "guillotine": {
      "getChildren": [
        {
          "displayName": "P!nk"
        },
        {
          "displayName": "Missy Elliott"
        },
        {
          "displayName": "Cardi B"
        }
      ]
    }
  }
}
----

Neat! Next, let's try a slightly more complicated query. In this one,  we'll also get the data inside the content nodes and extract their names and alias fields.

.A GraphQL query that fetches all {content-type-1}s and their data
[source, GraphQL,{subs}]
----
{
  guillotine {
    getChildren(key: "${site}/{content-type-1}s/")
    {
      displayName
      ... on {project-name-query}_{content-type-1-capitalized} {
        data {
          name
          about
        }
      }
    }
  }
}
----

Execute this and your response should look a little something like this:

.{content-type-1-capitalized}s and their aliases as returned by GraphQL
[source,JSON,{subs}]
----
{
  "data": {
    "guillotine": {
      "getChildren": [
        {
          "displayName": "Missy Elliott",
          "data": {
            "name": "Melissa Arnette Elliott",
            "about": "{about-missy}"
          }
        },
        {
          "displayName": "P!nk",
          "data": {
            "name": "Alecia Beth Moore",
            "about": "{about-pink}"
          }
        },
        {
          "displayName": "Cardi B",
          "data": {
            "name": "Belcalis Marlenis Almánzar",
            "about": "{about-cardi}"
          }
        }
      ]
    }
  }
}
----
