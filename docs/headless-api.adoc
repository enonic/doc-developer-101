= {title-headless-api}
include::.variables.adoc[]
:description: {description-headless-api}

Enonic is a hybrid CMS, which means that it can be used to manage and deliver content to your frontend. 

Now that we've created some content, let's see how we can access and use it in via API - headless style. 

In order to do that we'll introduce _Guillotine_, the app that's responsible for automatically generating GraphQL APIs for your content.

NOTE: If you are not interested in using Enonic in headless mode, you can skip to the next {document}, in which the standard way of using XP will be introduced.

== Installing Guillotine

The first thing you need to do in order to get going is installing the Guillotine application. It is available on https://market.enonic.com/vendors/enonic/guillotine[Enonic Market].

Fortunately, you can install Guillotine directly from your Enonic XP instance's admin console.

. From the XP menu (top right), choose `Applications`.
. Click kbd:[Install] from the top menu
. Search for `Guillotine`, and click kbd:[Install]`.
+
image::install-guillotine.png[Install Guillotine application dialog, {image-xl}]

== Query playground

Back in Content Studio, you should now have access to a new item called `Query playground` in the left green widget sidebar. Open it, and you should see this:

image::query-playground-empty.png[API browser integrated in Content Studio, {image-xl}]

Query playground is an interactive GraphQL API explorer. You enter your query in the text area to your left and when you execute it, you'll get the results of the query on the other side of the screen.

GraphQL is a graph "query language". It allows you to create highly specific queries for exactly the content that you need (visit the https://graphql.org/learn/[official GraphQL docs to learn more]).

As an example on how to retrieve some minimal info about your previously created artists, run the following query:

[source,GraphQL]
----
{
  guillotine {
    getChildren(key:"/artists") {
      displayName
      _path
      _id
    }
  }
}
----

After running, you should get something like this on the right area:

.Results of running the suggested query
image::query-playground-artists-minimal.png[Query playground response of running mimimal query to retrieve artists, {image-xl}]


Before trying to come up with complex queries, let's make familiarize ourselves with Query Playground.

=== Basic buttons

image::query-playground-buttons-1-to-4.png[Query playground buttons labelled from 1 to 4 for further detailing, width=100, align=center]

. _play button_, will execute your query. Shortcut is kbd:[ctrl+enter]
. _prettify button_, will properly format your query, removing comments and unecessary spaces / indentation. Shortcut is kbd:[ctl+shift+p]
. _merge fragments button_, will rewrite your query based on the declared https://graphql.org/learn/queries/#fragments[fragments]. Shortcut is kbd:[ctl+shift+m] 
. _copy button_, will copy your query to your clipboard. Shortcut is kbd:[ctl+shift+c]

image::query-playground-buttons-5-and-6.png[Query playground buttons labelled as 5 and 6 for further detailing, width=50, align=center]

[start=5]
. _docs button_, will open a section showing all details about the schemas you have avaiable to use and query on
. _history button_, will open a section showing all previously executed queries

image::query-playground-buttons-7-and-8.png[Query playground buttons labelled as 7 and 8 for further detailing, width=200, align=center]

[start=7]
. _tab button_, will create new tabs for you to manage testing multiple queries
. _draft / master buttons_ will switch between those two repositories for your queries to run on

image::query-playground-buttons-9-to-11.png[Query playground buttons labelled as 9 to 11 for further detailing, width=50, align=center]

[start=9]
. _re-fetch schema button_, will update your graphql schemas based on recent changes
. _shortkeys button_, will open a dialog displaying all short keys that can be used to execute actions
. _settings button_, will open settings dialog

=== Schemas

Now, locate and click on the docs button. On this opened section you have detailed info about all https://graphql.org/learn/schema/[schemas] available on your project.

On the top search bar in the docs section, search for `artist` and locate the `com_example_myproject_Artist` schema:

.The Artist schema
image::query-playground-artist-schema.png[Query playground docs section showing the details of com_example_myproject_Artist schema, {image-xl}]

Note that it's said that the `Artist` schema _implements_ the `Content` schema. This basically means that the `Artist` schema will have the structure defined by the `Content` schema, together with possibly some additional structure... in this case, that additional structure is a `data` field, defined by `com_example_myproject_Artist_Data` schema:

.The Artist data schema
image::query-playground-artist-data-schema.png[Query playground docs sections showing the details of com_example_myproject_Artist_Data schema, {image-xl}]

NOTE: Note that this matches the structure defined by the Artist content type, which is a natural thing to expect.  

=== Querying with inline fragments

We've used the Docs section to inspect the structure of the `Artist` schema. Let's now, based on a broader understanding of this schema, we'll query to get proper data from artists.

Close the docs section, head back to the text area to edit your query and remove `displayName`, `_path` and `_id` from the query we introduced earlier.

Now, with your cursor on the inner curly braces of the query, press kbd:[ctrl+space] to get a list of suggestions about what fields you can request on your query:

image::query-playground-artist-query-inspection.gif[Query playground query section showing suggested fields for content schema, {image-l}]

As can be seen, we do not have the artist `name` and `about` fields available, and the reason for that is because the `getChildren` field can return any content that implements the `Content` schema, but it can't directly infer what schema that is, which in this case is the `com_example_myproject_Artist` schema:

.getChildren can't directly infer what schema is implementing Content schema
image::query-playground-getChildren-infer.png[Query playground getChildren can't directly infer what schema is implementing Content schema, {image-xs}, align=center]

So to proceed, we use https://graphql.org/learn/queries/#inline-fragments[inline fragments]:

[source,GraphQL]
----
{
  guillotine {
    getChildren(key: "/artists") {
      ... on com_example_myproject_Artist {
        _id
        data {
          name
          about
        }
      }
    }
  }
}
----

With this, we basically built a query that understands that under `"/artists"` path we have content types of `Artist`, and based on this we can request general content data, such as `_id`, but also specific content data, such as the artist name and about:

.Getting specific data of artists
image::query-playground-artists-data.png[Query playground query returning artists content together with its name and about data, {image-xl}]

=== Query with dataAsJson

If you don't need or care about types when creating your queries, you can ignore the previously presented inline fragment approach and use the field `dataAsJson`:

[source,GraphQL]
----
{
  guillotine {
    getChildren(key: "/artists") {
      _id
      dataAsJson
    }
  }
}
----

.Getting all data using dataAsJson
image::query-playground-artists-dataAsJson.png[Query playground query returning artists content together with is name and about data, but using dataAsJson field, {image-xl}]

== Advanced queries

We'll now introduce and show examples of usaged of three different fields underneath `guillotine` field, that allos us to search the system for specific data.

=== Query

There is a `query` field underneath `guillotine` which allows you to search the system for what you want. This field accepts a number of optional, named arguments to help you find exactly what you're looking for. These arguments are:

`contentTypes`:: The content types we're looking for. Can either be a lone string if you're looking for a single content type, or a list if you want to search among multiple types.
`filters`:: A list of filters to apply to the results after the query has been executed. We won't get into them here, so if you want to learn more about them, head to the https://developer.enonic.com/docs/xp/stable/storage/filters[filters documentation].
`first`:: Specify how many nodes you want at most in your result. If your query yields a list of results, you can specify that you only want the first `n` results, where `n` is a positive integer. Works well in concert with offset.
`offset`:: Specify how many results you want to cut from the beginning of the list of results. Most commonly used for pagination.
`query`:: A https://developer.enonic.com/docs/xp/stable/storage/noql#query[NoQL query] string.
`sort`:: A https://developer.enonic.com/docs/xp/stable/storage/noql#sort[NoQL sort] string.

For instance, using the data set we've created previously in this guide, we could run a query like this:

.A Guillotine query using some of the arguments mentioned.
[source,GraphQL,{subs}]
----
{
  guillotine {
    query(
      first: 1
      contentTypes: "{project-name-full}:{content-type-1}" // <1>
      sort: "displayName desc"
    ) {
      _id
      displayName
    }
  }
}
----

<1> To query for multiple types, enclose them in square brackets and separate them with commas.

Note now that this query is getting the last artist that is alphabetically sorted by name, regardless of where the content type is located in the tree structure.

To perform a more advanced query, you can use the `query` argument. 

The following GraphQL query uses the https://developer.enonic.com/docs/xp/stable/storage/noql#ngram[n-gram query functionality] to find all the {content-type-1}s that have a term (part of a text) that starts with `rap` somewhere in their data.

.A Guillotine query using _nGram_ search functionality
[source,GraphQL,{subs}]
----
{
  guillotine {
    query(
      contentTypes: "{project-name-full}:{content-type-1}"
      query: "ngram('_allText', 'rap')"
      sort: "displayName asc"
    ) {
      displayName
    }
  }
}
----

Naturally, you can also use the standard boolean operators to combine or negate clauses. If you wanted to find all {content-type-1}s that mention both rapping and singing, you could try a query like this:

.Querying for {content-type-1}s who both rap and sing
[source,GraphQL,{subs}]
----
{
  guillotine {
    query(
      contentTypes: "{project-name-full}:{content-type-1}"
      query: "ngram('_allText', 'rap') AND ngram('_allText', 'sing')"
      sort: "displayName asc"
    ) {
      displayName
    }
  }
}
----

TIP: To learn more about query capabilities, visit the https://developer.enonic.com/docs/xp/stable/storage/noql[NoQl reference]

=== QueryDSL

Just like there is a `query` field underneath `guillotine`, the API also provides other fields such as `queryConnection`, `queryDsl` and `queryDslConnection`.

We'll not go into much details, but basically, the fields with _connection_ in their name have new parameters for aggregating data, whereas in the fields with _dsl_ (doman specific language), the query argument is not a string but Guillotine own specific DSL.

To make it clear, we'll rewrite the last query that used `ngram` using the queryDsl field:

.Querying for {content-type-1}s who both rap and sing, using queryDsl
[source,GraphQL,{subs}]
----
{
  guillotine {
    queryDsl(
      query: {
        boolean: {
          must: {
            term: {
              field: "type"
              value: {
                string: "{project-name-full}:{content-type-1}"
              }
            }
            ngram: {
          		fields: "data.about"
          		query: "rap sing"
              operator: AND
            }
          }
        }
      }
      sort: {
        field: "displayName"
        direction: ASC
      }
    ) {
      displayName
    }
  }
}
----

As expected, the results from this and the previous query must match, since we're essentially doing the same, but with `queryDsl` it is unlikely we'll create invalid queries, since we are using a fixed structure rather than a string.

NOTE: If you've previously used Elasticsearch API to query data, you'll be quite familiar with how `queryDsl` works!

TIP: To learn more about queryDSL capabilities, visit the https://developer.enonic.com/docs/xp/stable/storage/dsl[DSL reference]

=== QueryDslConnection

To finish this {document}, we'll add a new _birthyear_ field to the artist content type, update all artist to have data on this field, and then use `queryDslConnection` field to get aggregated data. Let's get to work!

. Start by updating the Artist content type to the following structure: 

[source, xml]
----
<content-type>
  <display-name>Artist</display-name> 
  <description>Information about an artist</description> 
  <super-type>base:structured</super-type>
  <form> 

    <input name="name" type="TextLine"> 
      <label>Name</label>
      <help-text>
        The artist's name (if different from their professional moniker).
      </help-text>
    </input>

    <input type="TextArea" name="about">
      <label>About the artist</label>
    </input>

    <input type="Date" name="birthday" >
      <label>Birthday</label>
    </input>

  </form>
</content-type>
----

[start=2]
. If are not running the project in dev mode (`enonic project dev` introduced in the previous ${document}), make sure to run `enonic project deploy` in the terminal on the project's root directory

. Update each of the previously created artists with the following dates:

- P!nk: 1979-09-08
- Missy Elliot: 1971-07-01
- Cardi B.: 1992-10-11

. Go back to Query playground and click on the _re-fetch schema button_. This will update the Artist data schema to contain the birthday structure, which is in sync with the Artist content type structure

. Run the following query on the playground:
+
[source,GraphQL,{subs}]
----
{
  guillotine {
    queryDslConnection(
      query: {
        boolean: {
          must: {
            term: {
              field: "type"
              value: {
                string: "{project-name-full}:{content-type-1}"
              }
            }
            exists: {
              field: "data.birthday"
            }
          }
        }
      }
      aggregations: {
        name: "generationsAggregation"
        dateRange: {
          field: "data.birthday"
          ranges: [
            {
              key: "The Greatest Generation"
              from: "1901"
              to: "1927"
          	}
            {
              key: "The Silent Generation"
              from: "1928"
              to: "1945"
          	}
            {
              key: "The Baby Boomer Generation"
              from: "1946"
              to: "1964"
          	}
            {
              key: "Generation X"
              from: "1965"
              to: "1980"
          	}
            {
              key: "Millennials"
              from: "1981"
              to: "1996"
          	}
            {
              key: "Generation Z"
              from: "1997"
              to: "2012"
          	}
            {
              key: "Gen Alpha"
              from: "2013"
              to: "2025"
          	}
          ]
          }
        }
    )
    {
      aggregationsAsJson
    }
  }
}
----

And this are the results
[source, json]
----
{
  "data": {
    "guillotine": {
      "queryDslConnection": {
        "aggregationsAsJson": {
          "generationsAggregation": {
            "buckets": [
              {
                "key": "The Greatest Generation",
                "docCount": 0,
                "from": "1901-01-01T00:00:00Z",
                "to": "1927-01-01T00:00:00Z"
              },
              {
                "key": "The Silent Generation",
                "docCount": 0,
                "from": "1928-01-01T00:00:00Z",
                "to": "1945-01-01T00:00:00Z"
              },
              {
                "key": "The Baby Boomer Generation",
                "docCount": 0,
                "from": "1946-01-01T00:00:00Z",
                "to": "1964-01-01T00:00:00Z"
              },
              {
                "key": "Generation X",
                "docCount": 2,
                "from": "1965-01-01T00:00:00Z",
                "to": "1980-01-01T00:00:00Z"
              },
              {
                "key": "Millennials",
                "docCount": 1,
                "from": "1981-01-01T00:00:00Z",
                "to": "1996-01-01T00:00:00Z"
              },
              {
                "key": "Generation Z",
                "docCount": 0,
                "from": "1997-01-01T00:00:00Z",
                "to": "2012-01-01T00:00:00Z"
              },
              {
                "key": "Gen Alpha",
                "docCount": 0,
                "from": "2013-01-01T00:00:00Z",
                "to": "2025-01-01T00:00:00Z"
              }
            ]
          }
        }
      }
    }
  }
}
----

Which shows that two of those artists are from Generation X, and one of them is a Millenial.

== Dive deeper

- For more query examples and information about how to get up and running with Guillotine, you can check out https://developer.enonic.com/docs/headless-cms-intro[the headless CMS intro guide] or the https://developer.enonic.com/docs/guillotine[Guillotine docs]
- If you want to understand how to extend available schemas on the GraphQL Api, you can head to https://developer.enonic.com/docs/guillotine/stable/embed/extending[Extending section on Guillotine docs] or check some examples on this https://developer.enonic.com/docs/build-a-custom-selector#customizing_with_guilliotine_lib_optional[guide]
- If you want to learn more about GraphQL in general, the https://graphql.org/learn/[_Introduction to GraphQL_ documentation] is a good place to start
