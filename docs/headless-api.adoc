= {title-headless-api}
include::variables.adoc[]

Now that we've created some content, let's see how we can use it in a headless fashion. This {document} introduces _Guillotine_, the library that's responsible for automatically generating GraphQL APIs for your content.

For the rest of this guide, whenever we're demonstrating headless functionality, we'll be using concepts introduced in this {document}. When we're talking headless functionality specifically, it'll be under a header that specifies it. If you're not interested in working headlessly, feel free to skip these sections.

NOTE: {see-prev-docs} In this {document}, you won't be building anything new, but we use the data set that we've created thus far.

== Headless: Querying the API

So we've created a custom content type and used it to create content, but what good is content if we can't access it from anywhere? Luckily, the headless starter kit has our backs! When using the headless starter kit, we get a GraphQL API automatically generated without any additional work.

NOTE: GraphQL is a graph "query language". It allows you to create highly specific queries for exactly the content that you need.

The headless starter uses an XP library called https://market.enonic.com/vendors/enonic/guillotine-headless-lib[Guillotine] to dynamically expose all our editorial content. We'll learn more about how this works later, but for now (with the default configuration) we can find the API at {p1-api-url}.

NOTE: If you have used a different name than "{p1-site-name}" for your site, you'll have to modify the URL a little: Switch `{p1-site-slug}` for the path of your site. See the Guillotine reference docs for an https://developer.enonic.com/docs/guillotine/stable/usage#context[explanation of how the URL is generated].

After navigating to the API, you'll find the _GraphQL playground_ waiting for you. The GraphQL playground is an interactive API explorer for GraphQL APIs. You enter your query in the text area to your left and when you execute it, you'll get the results of the query on the other side of the screen.

.The GraphQL playground
image::graphql-playground-empty.png[An empty GraphQL playground, {image-xl}]

In this {document}, we'll only barely dip our toes into the waters of GraphQL. We'll explore this further in the coming {document}s, but if you're interested, you can always check out the https://graphql.org/learn/[GraphQL docs].

To see what GraphQL can do for us, let's see if we can just fetch all the {content-type-1}s that we created. Copy the below query into your playground and run it by pressing kbd:[ctrl+enter]/kbd:[⌘+enter] or by clicking the play button.

.A GraphQL query fetching all content below the "{p1-site-name}" site
[source,GraphQL,{subs}"]
----
{
  guillotine {
    getChildren(key: "${site}/{content-type-1}s")
    {
      displayName
    }
  }
}
----

The result of this query should list all the {content-type-1}s you created previously as well as the Templates directory that came with the site:

.The result of the above query; all content nodes below "{content-type-1}s"
[source,JSON]
----
{
  "data": {
    "guillotine": {
      "getChildren": [
        {
          "displayName": "P!nk"
        },
        {
          "displayName": "Missy Elliott"
        },
        {
          "displayName": "Cardi B"
        }
      ]
    }
  }
}
----

Neat! Next, let's try a slightly more complicated query. In this one,  we'll also get the data inside the content nodes and extract their names and alias fields.

.A GraphQL query that fetches all {content-type-1}s and their data
[source, GraphQL,{subs}]
----
{
  guillotine {
    getChildren(key: "${site}/{content-type-1}s/")
    {
      displayName
      ... on {project-name-query}_{content-type-1-capitalized} {
        data {
          name
          about
        }
      }
    }
  }
}
----

Execute this and your response should look a little something like this:

.{content-type-1-capitalized}s and their aliases as returned by GraphQL
[source,JSON,{subs}]
----
{
  "data": {
    "guillotine": {
      "getChildren": [
        {
          "displayName": "Missy Elliott",
          "data": {
            "name": "Melissa Arnette Elliott",
            "about": "{about-missy}"
          }
        },
        {
          "displayName": "P!nk",
          "data": {
            "name": "Alecia Beth Moore",
            "about": "{about-pink}"
          }
        },
        {
          "displayName": "Cardi B",
          "data": {
            "name": "Belcalis Marlenis Almánzar",
            "about": "{about-cardi}"
          }
        }
      ]
    }
  }
}
----


== The Guillotine library

If you've been wondering how the GraphQL API we've been querying up until now was created: the Guillotine library is the answer. The Guillotine library analyzes all the content in your applications and generates an API from that. It' s an optional library that comes preconfigured with the headless starter that we used back xref:apps#_projects_and_starters[way back when we first created our app in a previous {document}]. Guillotine provides direct, typed, and documented access to content within your site.

If you're familiar with GraphQL, you might have noticed that we have not performed any mutations yet. The reason for that is simple: Guillotine only exposes the read-only part of the Enonic Content API, so mutations are not available.

=== Integrating Guillotine

When we created an app in xref:apps#_projects_and_starters[a previous chapter], we used the headless starter, which comes which comes with Guillotine integrated. As such, we haven't had to worry ourselves with how to integrate it with XP. However, to better understand how it works, let's have a little peek under the hood.

The recommended way to embed Guillotine within your app is to use it as a library. To do this,  add a dependency on the library in the `build.gradle` at the root of your project. The `build.gradle` file that comes with the headless starter will look something like this:

.A `build.gradle` file as included with the headless starter
[source,groovy]
----
plugins {
    id 'com.enonic.xp.app' version '3.0.0'
}

apply plugin: "com.enonic.xp.app"

app {
    name = "${appName}"
    displayName = "${appDisplayName}"
    vendorName = "${vendorName}"
    vendorUrl = "${vendorUrl}"
    systemVersion = "${xpVersion}"
}

dependencies {
    compile "com.enonic.xp:portal-api:${xpVersion}"
    include "com.enonic.xp:lib-websocket:${xpVersion}"
    include "com.enonic.lib:lib-guillotine:5.0.1" <--.-->
    include "com.enonic.lib:lib-graphql-playground:0.0.1"
}

repositories {
    mavenLocal()
    jcenter()
    xp.enonicRepo( 'dev' )
}
----

<.> This line includes Guillotine version 5.0.1

This tells XP that we're going to be using the library. However, it doesn't do anything just yet. To make it work, we're going to need to create a _mapping_ and a _controller_. Both of these concepts will be explained in more detail in a later chapter, but the short form is that a _mapping_ routes HTTP requests to a path to a _controller_. The controller is then responsible for processing and responding to the HTTP request.

The headless starter takes care of this for us by mapping requests to an `/api` path to a controller named `graphql.js` using the `mappings` element:

.A `site.xml` file with mappings
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<site>
  <form />
  <mappings>
    <mapping controller="/controllers/graphql.js" order="50"> <--.-->
      <pattern>/api</pattern> <--.-->
    </mapping>
  </mappings>
</site>
----

<.> This tells XP that requests that match this mapping's pattern should be routed to the `/controllers/graphql.js` controller
<.> This pattern tells XP that what reuqests to send to this mapping's controller. In this case, it's any requests to `<site-url>/api`, where `<site-url>` is the URL for your site.

The controller takes care of generating the schema and providing the API endpoints and logic. The headless starter comes with a default controller that provides the schema and the GraphQL playground that we've been using thus for. It's too long to include in this guide, but if you want to have a look at it, the https://github.com/enonic/starter-headless/blob/master/src/main/resources/controllers/graphql.js[headless starter GraphQL controller] is available on GitHub.

To learn more about the Guillotine library, how it works, and how you deploy it, check out the https://developer.enonic.com/docs/guillotine/stable[Guillotine reference docs].

== Advanced querying

When making a Guillotine query, you can use the `query` function underneath `guillotine` to specify what you want. This function accepts a number of optional, named arguments to help you hone in on exactly what you're looking for. These arguments are:

`contentTypes`:: The content types we're looking for. Can either be a lone string if you're looking for a single content type, e.g. or a list if you want to search among multiple types:
+
.Querying for a single content type
  query(contentTypes: "{project-name-full}:{content-type-1}")
+
.Querying for multiple content types
  query(contentTypes: "{project-name-full}:{content-type-1}", "{project-name-full}:{content-type-2}")
+
`filters` :: A list of filters to apply to the results after the query has been executed. We won't get into them here, so if you want to learn more about them, head to the https://developer.enonic.com/docs/xp/stable/storage/filters[filters documentation].
`first`:: Specify how many nodes you want at most in your result. If your query yields a list of results, you can specify that you only want the first `n` results, where `n` is a positive integer. Works well in concert with offset.
`offset`:: Specify how many results you want to cut from the beginning of the list of results. Most commonly used for pagination.
`query`:: A https://developer.enonic.com/docs/xp/stable/storage/noql#query[NoQL query] string.
`sort`:: A https://developer.enonic.com/docs/xp/stable/storage/noql#sort[NoQL sort] string.

For instance, using the data set we've created previously in this guide, we could run a query like this:

.A Guillotine query using some of the arguments mentioned.
[source,GraphQL,{subs}]
----
{
  guillotine {
    query(
      first: 3,
      offset: 1,
      contentTypes:
      [ "{project-name-full}:{content-type-1}",
	"{project-name-full}:{content-type-2}" ],
      sort: "displayName desc") {
      displayName
      contentType {
        displayName
      }
    }
  }
}
----

This query would produce a result like the following:

.Guillotine query result
[source,json]
----
{
  "data": {
    "guillotine": {
      "query": [
        {
          "displayName": "P!nk",
          "contentType": {
            "displayName": "Artist"
          }
        },
        {
          "displayName": "Missy Elliott",
          "contentType": {
            "displayName": "Artist"
          }
        },
        {
          "displayName": "Lion",
          "contentType": {
            "displayName": "Animal"
          }
        }
      ]
    }
  }
}
----

To perform a more advanced query, you can use the `query` parameter. The following query uses the https://developer.enonic.com/docs/xp/stable/storage/noql#ngram[n-gram query functionality] to find all the {content-type-1}s that mention `rap` somewhere in their data.

.A Guillotine query using _nGram_ search functionality
[source,GraphQL,{subs}]
----
{
  guillotine {
    query(
      contentTypes: "{project-name-full}:{content-type-1}"
      query: "ngram('_allText', 'rap')"
      sort: "displayName asc") {
      displayName
    }
  }
}
----

The result would look something like this:

.Rap results
[source,json]
----
{
  "data": {
    "guillotine": {
      "query": [
        {
          "displayName": "Cardi B"
        },
        {
          "displayName": "Missy Elliott"
        }
      ]
    }
  }
}
----

Naturally, you can also use the standard boolean operators to combine or negate clauses. If you wanted to find all {content-type-1}s that mention both rapping and singing, you could try a query like this:

.Querying for {content-type-1}s who both rap and sing
[source,GraphQL,{subs}]
----
{
  guillotine {
    query(
      contentTypes: "{project-name-full}:{content-type-1}"
      query: "ngram('_allText', 'rap') AND ngram('_allText', 'sing')"
      sort: "displayName asc") {
      displayName
    }
  }
}
----

And find out that with our data set, there's only one:

.Rappers and singers
[source,json]
----
{
  "data": {
    "guillotine": {
      "query": [
        {
          "displayName": "Missy Elliott"
        }
      ]
    }
  }
}
----

== Learn more

For a detailed overview of the node query language and an extensive example selection, https://developer.enonic.com/docs/xp/stable/storage/noql[the NoQL reference] is the place to go. For more query examples and information about how to get up and running with Guillotine, you can check out https://developer.enonic.com/guides/headless-cms-intro[the headless CMS intro guide].

If you want to learn more about GraphQL, the https://graphql.org/learn/[_Introduction to GraphQL_ documentation] is a good place to start.
