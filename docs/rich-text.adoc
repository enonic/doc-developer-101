= Rich text: HtmlArea
include::variables.adoc[]
:macro-name: screamingSnakeCase

When you want to ... rich text is the way to go, and if you want to work with rich text in Content Studio, HtmlArea is your friend.

We briefly mentioned the HtmlArea input type in the previous {document}, but didn't say much about it -- not because there's nothing to be said about it. The situation is actually quite the opposite. This rich text input type offers some very powerful editing capabilities and a lot of configuration options. As such, this whole {document} is dedicated to that one input type, how it works, and how to use it in a headless fashion.

NOTE: The tasks in this {document} build on the content types we created and configured previously. If you want follow along to the tasks in this chapter, make sure you've followed the steps in the previous {document}s, starting from xref:content[the content types chapter].

== The HtmlArea: an overview

.The default HtmlArea input type
image::input-type-html-area.png[HtmlArea: A rich text input field with visible formatting options., width=600]

The HtmlArea input type gives you a multi-line input field with rich formatting options, much like what you're used to from your favorite word processor. It supports text formatting and justification, lists, links, and even lets you insert images.

You can configure the HtmlArea to be exactly what you want by dictating what formatting tools to include or exclude (the `include` and `exclude` attributes, respectively), by what heading levels are allowed (`allowedHeadings`), and by giving it a default value (`default`).

Additionally, the HtmlArea supports the use of _macros_. Macros let you automatically insert arbitrary markup into your rendered content and is perfect for cases when you want to add banners, add footers, contact info, or the like. // <- TODO: might need to rethink this ðŸ¤”

== Configuration of text tools

We can use the HtmlArea's `config` section to specify which rich text controls should be available when editing. Using a combination of the `include` and `exclude` tags, we can customize the input's appearance.

If you want to include all controls, use `<include>*</include>` as shown below:

.The HtmlArea configured to include everything
[source,xml]
----
<input type="HtmlArea" name="everything">
  <label>HtmlArea with 'include *'</label>
  <config>
    <include>*</include>
  </config>
</input>
----

.An HtmlArea input with `<include>*</include>`
image::input-type-html-area-all-controls.png["An HtmlArea configured to include all editing tools.", width=600]


If you want to exclude all controls, use `<exclude>*</exclude>`:


.The HtmlArea configured to include nothing
[source,xml]
----
<input type="HtmlArea" name="nothing">
  <label>HtmlArea with exclude: *</label>
  <config>
    <exclude>*</exclude>
  </config>
</input>
----

.An HtmlArea exput with `<exclude>*</exclude>`
image::input-type-html-area-no-controls.png[An HtmlArea configured to exclude all editing tools., width=600]

Finally, if you want to exclude most tools, but not all, you can exclude all and then add back in the ones you want:

.The HtmlArea configured to include a selection of controls
[source,xml]
----
<input type="HtmlArea" name="something">
  <label>HtmlArea with some controls</label>
  <config>
    <exclude>*</exclude>
    <include>Format | Bold Italic Underline | JustifyBlock
    JustifyLeft JustifyCenter JustifyRight | HorizontalRule Blockquote</include>
  </config>
</input>
----

.An HtmlArea with a selection of tools and `<exclude>*</exclude>`
image::input-type-html-area-some-controls.png[An HtmlArea configured to include a selection of editing tools., width=600]

== Task: Add a rich text area to your {content-type-2-capitalized} content type

Your {content-type-2-capitalized} already has a TextArea input type for 'description'. Let's upgrade that to an HtmlArea input type.

The input should be optional have at most a single occurrence. You can include any editor tools you want, but it must at least have the `image` and `macro` tools, as we'll be using these later. Otherwise, configure it as you want.

Once you've done that, add some text to one of your {content-type-2}s and try out the HtmlArea.

It'll look a little something like this:

.{content-type-2-capitalized} with an HtmlArea input type
[source,xml,subs={subs}]
----
<?xml version="1.0" encoding="utf-8"?>
<content-type>
  <display-name>{content-type-2-capitalized}</display-name>
  <description>An {content-type-2} that lives on planet Earth</description>
  <super-type>base:structured</super-type>
  <form>

    <input name="name" type="TextLine">
      <label>Name</label>
      <help-text>
        Put the name of the animal here. You can be as
        specific or as vague as you like. "Dog" is just as good as
        "Canis lupus familiaris".
      </help-text>
      <occurrences minimum="1" maximum="0"></occurrences>
    </input>

    <input name="description" type="HtmlArea">
      <label>Description</label>
      <help-text>
        Describe the animal. Where its habitats are, what it eats, etc.
      </help-text>
      <config>
        <exclude>*</exclude>
        <include>Format Macro Image</include>
      </config>
    </input>

  </form>
</content-type>
----

== Images

If you have configured your HtmlArea to include the image tool, you can click the image button to insert an image. Once you select an image, you'll get a prompt that allows you to customize the image. You can add a caption, alt text, change the image's justification in the block, and apply predefined styles. There's also a pencil icon in the upper right corner that allows you to edit the image, as covered in xref:input-types#_working_with_images[a previous {document}].

== Task: Add an image to an {content-type-2}

Try out the image controls that Content Studio gives you by uploading a picture and seeing what you can do with it. Remember to click the pencil icon to try the advanced editing tools such as cropping and focal points.

== Macros

Macros allow you to easily add content and formatting to your rich text area. When the page is rendered, the macro call is resolved and replaced. When the macro is resolved, it will either add text to your page or styles or scripts. See the https://developer.enonic.com/docs/xp/stable/cms/macros[macro reference docs] for a more in-depth explanation of how this works. In this guide, we'll see some examples of macros and then look at how we can create our own.

=== Using macros

Adding macros to HtmlAreas looks quite a lot like the XML configuration we've been doing up until now, except that we use square brackets instead of angle brackets (`[]` instead of `<>`). You specify the name and any required attributes. Some macros are self-closing and accept no contents, while others accept content and must be closed later. To close a self-closing macro, add a `/` before the first closing bracket (`]`).

.An example of a self closing macro
[src]
  [selfClosingMacro param="value" /]

.An example of a macro with content
[src]
  [contentMacro param="value"]This content goes inside the macro![/contentMacro]

A good example of what macros can be useful for is the https://market.enonic.com/vendors/enonic/com.enonic.app.panelmacros[`Panel Macros` XP app] which gives you colored panels that you can add important text to.

.The Panel Macros package image
image::macros-panel-macros.jpg["The Panel Macros package in action, showing differently colored panels." , width=600]

To use it, you'd pick your desired panel type (as listed in https://github.com/enonic/app-panel-macros#readme[the library documentation]), such as `success`. If you also want a header, you can specify that using the `header` attribute. If we wanted a `success` panel with a header, we'd add something like this to our HtmlArea:

.Using a panel macro
[src]
  [success header="Congrats!"]You did it! Give yourself a well-deserved pat on the back ðŸ¥³[/success]

=== Task: Creating our own macro

If you want to create your own macro, that's possible too, and it doesn't have to take too much work. The success macro above comes with a fair amount of styling too, so will do something simpler. We'll create a macro to transform the macro body 'SCREAMING_SNAKE_CASE': we'll put the text in all caps, and change every space into an underscore . For the macro header, we'll put it in all caps and surround it with asterisks. We'll call the macro `{macro-name}`.

NOTE: This section includes a little bit of JavaScript programming. If you're not familiar with it, don't worry: we'll provide you everything you need.

First off, let's create a _macro descriptor_. A macro descriptor is an XML file that lets you give a macro a friendly display name and a description, as well as a way for you to document the macro parameters. It's not strictly required, but very recommended. A macro descriptor goes in `src/main/resources/site/macros/<macro-name>/<macro-name>.xml`. In our case, that's `src/main/resources/site/macros/{macro-name}/{macro-name}.xml`. Here's the descriptor we'll be using:

.The XML descriptor for the {macro-name} macro
[src,xml]
----
<macro>
  <display-name>Screaming snake case</display-name>
  <description>Transform the text body into SCREAMING_SNAKE_CASE</description>

  <form>
    <input name="header" type="TextLine"> <!--1-->
      <label>Header</label>
      <occurrences minimum="0" maximum="1"/>
    </input>
    <input name="body" type="TextArea"> <!--2-->
      <label>Text</label>
      <occurrences minimum="1" maximum="1"/>
    </input>
  </form>
</macro>
----

<1> This is the `header` parameter. This has to be specified as a macro attribute.
<2> This is the `body` parameter. It's automatically mapped to whatever is inside the macro tag and is not assigned explicitly.

Notice how both inputs define what sort of input they accept (single and multi-line text respectively).

Now for a little bit of scripting. Next to the XML file, create a file called `{macro-name}.js`. We'll write a simple script that fetches the header and the body of the macro and transforms it.

.The {macro-name} script
[source,js]
----
exports.macro = (context) => {
  // Extract the header and body parameters <!--1-->
  const header = context.params['header'] && context.params['header'].trim()
  const body = context.body

  // define the transformation
  const changeCase = text => text.toUpperCase().replace(/ /g, "_")

  // create the optional header element
  const headerElement = header && header.length > 0 ?
        ('<strong>*' + header.toUpperCase() + '*: </strong>') : '';

  // return the body that replaces the macro <!--2-->
  return {
    body: '<span>'+ headerElement + changeCase(body) + '</span>'
  }
}
----

<1> The header parameter is available in the `context.params` object, while the body is available as a property on the `context` object directly.
<2> What you return from the macro is what it will be replaced with. In this case, that's the modified text.

Now make sure this is deployed to your XP instance (check xref:sandboxes#_sandboxes[the section on sandboxes in for how to start it]) either by having it run in development mode or by xref:apps#_building_and_deploying[redeploying your app].

Now we can either add this manually or by using the macro tool in the HtmlArea toolbar. If we use the macro tool we also get to preview the macro.

To do it manually, we'd enter this into the HtmlArea:

.The {macro-name} macro in use
[source,subs="attributes+"]
  [{macro-name} header="Screaming snakes"]Oh no what have you done?[/{macro-name}]

Using the macro tool, we'd get a popup form instead that prompts us for all the parameters:

.The insert macro prompt
image::macros-insert-macro.png[The input form for adding a macro, width=800 ]

To preview the macro, click the "preview" button:

.The macro preview function
image::macros-preview-macro.png[The macro preview, width=800]


== Rich text in a headless context

We've seen that rich text gives you a lot of power at your fingertips, but how does it work in a headless context? While it might be more immediately obvious how rich text works in a traditional CMS situation, that doesn't mean that it's not useful in headless contexts. The HtmlArea is called the HtmlArea for a very good reason: it turns the rich text that you see into HTML. That means that if you fetch content that has an input of type HtmlArea, you'll get HTML included in your response.

But the HtmlArea has even more tricks up its sleeves! The HtmlArea also supports specifying different dimensions for images, using the `srcset` attribute of the `img` element. We'll see how this works when performing the queries.

=== GraphQL queries

NOTE: Remember that GraphQL playground can be found at {p1-api-url}.

Now let's look at some actual queries. If we add an image and a macro to one of our {content-type-2}s, it might look a little something like this.

image::rich-text-content-macro-image["An {content-type-2} with an image and a macro inserted into its HtmlArea.",width=600]


We can fetch this in it's entirety with the following query:

.A query for {content-type-2}s
[source,graphql,subs={subs}]
----
{
  guillotine {
    getChildren(key: "/my-first-site/animals/")
    {
      displayName
      ... on com_example_myproject_Animal {
        data {
          name
          description {
            processedHtml
          }
        }
      }
    }
  }
}
----

The only thing about this query that we haven't seen before, is that `description` has a nested `processedHtml`. This is a feature introduced in Guillotine version 5, which gives you smoother handling of images and macros. You can also try fetching `raw` as a child of `description` and it will give you the unprocessed version of the same HTML, including macros before expansion.

The above query will yield something like this (depending on how many {content-type-2}s you have).

.A response to the {content-type-2} query
[source,json,subs={subs}]
----
{
  "data": {
    "guillotine": {
      "getChildren": [
        {
          "displayName": "Reindeer",
          "data": {
            "name": [
              "Reindeer",
              "Caribou"
            ],
            "description": {
              "processedHtml": "<p>The reindeer ...</p>\n\n<p>&nbsp;</p>\n\n<figure class=\"editor-align-justify\"><img alt=\"xp-login.png\" src=\"/site/default/draft/my-first-site/_/image/9a48f1fd-b000-4bfc-a053-911a703b4a65:689b4261abca3ddfc4dc891cf8bd39d4bf0bf879/width-768/snowy-hill.png\" data-image-ref=\"1648717e-5891-4ebd-af45-b278df224193\" style=\"width:100%\" />\n<figcaption></figcaption>\n</figure>\n\n<p><editor-macro data-macro-name=\"screamingSnakeCase\" data-macro-ref=\"23f481c5-e632-4416-ad42-16ce4485c606\">Reindeer are also known as caribou</editor-macro></p>\n"
            }
          }
        }
      ]
    }
  }
}
----

Additionally, we can also pass a `processHtml` argument to the description field and specify what sort of image widths we want. This is great for responsiveness and not serving your users larger images than what they need on their devices. For instance, if we want to get images sized at 50 and 200 pixels wide, we could write a query as below. This time we'll also include the `raw` rich text so you can compare the differences:

.A query that specifies image widths
[source,GraphQL,subs={subs}]
----
{
  guillotine {
    getChildren(key: "/my-first-site/{content-type-2}s/")
    {
      displayName
      ... on com_example_myproject_{content-type-2-capitalized} {
        data {
          name
          description(processHtml: {imageWidths: [50,200]}) {
            processedHtml
            raw
          }
        }
      }
    }
  }
}
----

That'll get us back something that looks like the following:

.A response including raw and processed HTML
[source,json,subs={subs}]
----
{
  "data": {
    "guillotine": {
      "getChildren": [
        {
          "displayName": "Reindeer",
          "data": {
            "name": [
              "Reindeer",
              "Caribou"
            ],
            "description": {
              "processedHtml": "<p>The reindeer ...</p>\n\n<p>&nbsp;</p>\n\n<figure class=\"editor-align-justify\"><img alt=\"xp-login.png\" src=\"/site/default/draft/my-first-site/_/image/9a48f1fd-b000-4bfc-a053-911a703b4a65:689b4261abca3ddfc4dc891cf8bd39d4bf0bf879/width-768/snowy-hill.png\" data-image-ref=\"043cf982-7996-4978-9d0a-cd1162d159aa\" srcset=\"/site/default/draft/my-first-site/_/image/9a48f1fd-b000-4bfc-a053-911a703b4a65:689b4261abca3ddfc4dc891cf8bd39d4bf0bf879/width-50/snowy-hill.png 50w,/site/default/draft/my-first-site/_/image/9a48f1fd-b000-4bfc-a053-911a703b4a65:689b4261abca3ddfc4dc891cf8bd39d4bf0bf879/width-200/snowy-hill.png 200w\" style=\"width:100%\" />\n<figcaption></figcaption>\n</figure>\n\n<p><editor-macro data-macro-name=\"screamingSnakeCase\" data-macro-ref=\"3caf649b-07a4-4560-ac92-c174b214f5d2\">Reindeer are also known as caribou</editor-macro></p>\n",
              "raw": "<p>The reindeer ...</p>\n\n<p>&nbsp;</p>\n\n<figure class=\"editor-align-justify\"><img alt=\"xp-login.png\" src=\"image://9a48f1fd-b000-4bfc-a053-911a703b4a65\" style=\"width:100%\" />\n<figcaption></figcaption>\n</figure>\n\n<p>[screamingSnakeCase header=\"Caribou!\"]Reindeer are also known as caribou[/screamingSnakeCase]</p>\n"
            }
          }
        }
      ]
    }
  }
}
----

Admittedly, this isn't the most comfortable way to read HTML, but if you look closely, you'll notice that the processed HTML uses `srcset` to include multiple resolutions of the same image. You'll also see that the macro is not expanded in the `raw` output, but that it uses an `editor-macro` element in the processed output.

== Next

We've looked at using simple input types to create content, but what if we want to do something more advanced? Next up: advanced content types, where we'll learn about grouping inputs together.
