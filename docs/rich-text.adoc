= Rich text: HtmlArea
include::variables.adoc[]
:macro-name: screamingSnakeCase
:macro-app: Panel Macros

If you want to work with rich text in Content Studio, HtmlArea is your friend. We briefly mentioned the HtmlArea input type in the previous {document}, but didn't say much about it -- not because there's nothing to be said about it. The situation is actually quite the opposite. This rich text input type offers some very powerful editing capabilities and a lot of configuration options. As such, this whole {document} is dedicated to that one input type, how it works, and how to use it in a headless fashion.

NOTE: {see-prev-docs}

== The HtmlArea: an overview

The HtmlArea input type gives you a multi-line input field with rich formatting options, much like what you're used to from your favorite word processor. It supports text formatting and justification, lists, links, and even lets you insert images.

You can configure the HtmlArea to be exactly what you want by dictating what formatting tools to include or exclude (the `include` and `exclude` attributes, respectively), by what heading levels are allowed (`allowedHeadings`), and by giving it a default value (`default`).

Additionally, the HtmlArea supports the use of _macros_, giving you the ability to insert prefabricated rich components into your markup.

== Configuration of text tools

We can use the HtmlArea's `config` section to specify which rich text controls should be available when editing. Using a combination of the `include` and `exclude` tags, we can customize the input's appearance.

By default, it includes a limited, but useful selection of tools at your disposal. Using `<include>*</include>` as an option is the same as including the default tools.

.The HtmlArea with default configuration
[source,xml]
----
<input type="HtmlArea" name="everything">
  <label>HtmlArea</label>
</input>
----

.The default HtmlArea input type
image::input-type-html-area.png[HtmlArea: A rich text input field with visible formatting options., width=600]


If you want to exclude all controls, use `<exclude>*</exclude>`:


.The HtmlArea configured to include nothing
[source,xml]
----
<input type="HtmlArea" name="nothing">
  <label>HtmlArea with exclude: *</label>
  <config>
    <exclude>*</exclude>
  </config>
</input>
----

.An HtmlArea exput with `<exclude>*</exclude>` and a selection of tools.
image::input-type-html-area-no-controls.png[An HtmlArea configured to exclude all editing tools., width=600]

Finally, if you want to exclude most tools, but not all, you can exclude all and then add back in the ones you want:

.The HtmlArea configured to include a selection of controls
[source,xml]
----
<input type="HtmlArea" name="something">
  <label>HtmlArea with some controls</label>
  <config>
    <exclude>*</exclude>
    <include>Format | Bold Italic Underline | JustifyBlock
    JustifyLeft JustifyCenter JustifyRight | HorizontalRule Blockquote</include>
  </config>
</input>
----

.An HtmlArea with a selection of tools and `<exclude>*</exclude>`
image::input-type-html-area-some-controls.png[An HtmlArea configured to include a selection of editing tools., width=600]

== Task: Add a rich text area to your {content-type-2-capitalized} content type

Let's add a rich-text description to our {content-type-2}s. The input should be optional have at most a single occurrence. You can include any editor tools you want, but it must at least have the `image` and `macro` tools, as we'll be using these later. Otherwise, configure it as you want.

Once you've done that, add some text to one of your {content-type-2}s and try out the HtmlArea.

It'll look a little something like this:

.{content-type-2-capitalized} with an HtmlArea input type
[source,xml,{subs}]
----
<?xml version="1.0" encoding="utf-8"?>
<content-type>
  <display-name>{content-type-2-capitalized}</display-name>
  <description>An {content-type-2} that lives on planet Earth</description>
  <super-type>base:structured</super-type>
  <form>

    <input type="TextLine" name="otherNames">
      <label>Other names</label>
      <help-text>Other names for this species.</help-text>
      <occurrences minimum="0" maximum="0" />
    </input>

    <input name="images" type="ImageSelector">
      <label>Images</label>
      <help-text>Images of the animal</help-text>
      <occurrences minimum="0" maximum="3" /> <!--4-->
    </input>

    <input name="description" type="HtmlArea">
      <label>Description</label>
      <help-text>
        Describe the animal. Where its habitats are, what it eats, etc.
      </help-text>
      <config>
        <exclude>*</exclude>
        <include>Format Macro Image</include>
      </config>
    </input>

  </form>
</content-type>
----

== Images

If you have configured your HtmlArea to include the image tool, you can click the image button to insert an image. Once you select an image, you'll get a prompt that allows you to customize the image. You can add a caption, alt text, change the image's justification in the block, and apply predefined image styles. There's also a pencil icon in the upper right corner that allows you to edit the image, as covered in xref:input-types#_working_with_images[a previous {document}].

== Task: Add an image to an {content-type-2} and style it

Try out the image controls that Content Studio gives you by uploading a picture and seeing what you can do with it. Remember to click the pencil icon to try the advanced editing tools such as cropping and focal points.

We looked at xref:input-types#_working_with_images[editing images in the previous {document}], but the HtmlArea also offers you something called "image styles", which we'll have a look at now.

When you insert an image via the HtmlArea toolbar, you'll be greeted by the "insert image" dialog:

.The HtmlArea insert image dialog. Photo by https://unsplash.com/@kydroon[Kurt Cotoaga] ü¶Å
image::rich-text-insert-image.png["The insert image dialog, showing the image, an image styles dropdown, caption, and alt text fields", width=800]

If you try and access the "image styles" dropdown, you'll find that it's only got two options and neither of them seem to do much. To make this more exciting, let's also create a custom image style.

In a new file, `src/main/resources/site/styles.xml`, place the following simple style configuration:

.A very basic styles configuration
[source,xml,{subs}]
----
<styles>
  <image name="conteditor-style-grayscale">
    <display-name>Grayscale</display-name>
    <filter>hsbcolorize(0x000000); grayscale(); border(6, 0x000000)</filter>
  </image>
</styles>
----

The above configuration turns the image into grayscale and adds a border to the image.

NOTE: https://developer.enonic.com/docs/xp/stable/cms/styles[The styles reference docs] have more information on how you can style your images, so go check it out for a deeper dive.

With this style picked up by XP, you'll have the "Grayscale" option available in the image styles dropdown. Select it to apply it to the image.

.An image with an image style applied
image::rich-text-insert-image-styled.png["The insert image dialog showing the results of applying the image styles to the image", width=800]

=== Headless: fetching images and styles from HtmlArea

When you add a an image to a rich text input, you can fetch it via GraphQL using the `processedHtml` sub selection of your rich text field.  Let's look at how that works. To start us off, this query finds the piece of content that we added the added the image to (the "Lion" ü¶Å) and extracts its processed HTML from its description.

This simple query just fetches the processed HTML of the HTML area:

.Fetching rich text
[source,GraphQL,{subs}]
----
{
  guillotine {
    query(contentTypes:"{project-name-full}:{content-type-2}",
      query: "displayName = 'Lion'") {
      ... on {project-name-query}_{content-type-2-Capitalized} {
        data {
          description {
            processedHtml
          }
        }
      }
    }
  }
}
----

In the returned HTML, you can see the image with styles applied. If you extract the `src` value and add it after `localhost:8080` (or any other instance), you should find the image with styles applied.

.The query result for the processed HTML
[source,json]
----
{
  "data": {
    "guillotine": {
      "query": [
        {
          "data": {
            "description": {
              "processedHtml": "<figure class=\"captioned editor-align-justify editor-style-grayscale\"><img alt=\"A yawning lion cub\" src=\"/site/default/draft/my-first-site/_/image/ef8605b1-6966-4011-bbfe-65c4c2e9ec86:d5d96909fc488356fd24e67763cbb1868b3f77c3/width-768/lion-cub.jpg?filter=hsbcolorize%280x000000%29%3B+grayscale%28%29%3B+border%286%2C+0x000000%29\" data-image-ref=\"23dc2b52-2e06-46cc-b42c-953ef51ae650\" style=\"width:100%\" />\n<figcaption>Soooo sleepy üò™</figcaption>\n</figure>\n\n<p>&nbsp;</p>\n"
            }
          }
        }
      ]
    }
  }
}
----

But wait, there's more! You can also get the image in different sizes (using https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/srcset[the `srcset` attribute (MDN)]) by adding a `processHtml` argument to `description`:

.Fetching rich text with `srcset`
[source,GraphQL,{subs}]
----
{
  guillotine {
    query(contentTypes:"{project-name-full}:{content-type-2}",
      query: "displayName = 'Lion'") {
      ... on {project-name-query}_{content-type-2-Capitalized} {
        data {
          description(processHtml: {imageWidths: [200, 500]}) {
            processedHtml
          }
        }
      }
    }
  }
}
----

That'll get you a result that looks like this:

.Result with `srcset`
[source,json]
----
{
  "data": {
    "guillotine": {
      "query": [
        {
          "data": {
            "description": {
              "processedHtml": "<figure class=\"captioned editor-align-justify editor-style-grayscale\"><img alt=\"A yawning lion cub\" src=\"/site/default/draft/my-first-site/_/image/ef8605b1-6966-4011-bbfe-65c4c2e9ec86:d5d96909fc488356fd24e67763cbb1868b3f77c3/width-768/lion-cub.jpg?filter=hsbcolorize%280x000000%29%3B+grayscale%28%29%3B+border%286%2C+0x000000%29\" data-image-ref=\"21d88d0f-aa30-4c0b-9830-37893f9ff642\" srcset=\"/site/default/draft/my-first-site/_/image/ef8605b1-6966-4011-bbfe-65c4c2e9ec86:d5d96909fc488356fd24e67763cbb1868b3f77c3/width-200/lion-cub.jpg?filter=hsbcolorize%280x000000%29%3B+grayscale%28%29%3B+border%286%2C+0x000000%29 200w,/site/default/draft/my-first-site/_/image/ef8605b1-6966-4011-bbfe-65c4c2e9ec86:d5d96909fc488356fd24e67763cbb1868b3f77c3/width-500/lion-cub.jpg?filter=hsbcolorize%280x000000%29%3B+grayscale%28%29%3B+border%286%2C+0x000000%29 500w\" style=\"width:100%\" />\n<figcaption>Soooo sleepy üò™</figcaption>\n</figure>\n\n<p>&nbsp;</p>\n"
            }
          }
        }
      ]
    }
  }
}
----

If reading escaped HTML in a JSON string isn't your favorite thing, the important part of the above result is that we've gotten a `srcset` attribute for our image, which means that the browser will pick the size of the image that best suits the current situation (based on screen sizes etc.), and use a smaller image when possible. This means fewer bytes across the wire and faster load times!

And finally, what if we want to extract styling info? In our case, the styling is done on the server, but in case you want to fetch and use that for some reason, we can do that too:

.Fetching image styles from an HtmlArea
[source,GraphQL,{subs}]
----
{
  guillotine {
    query(contentTypes:"com.example.myproject:animal",
      query: "displayName = 'Lion'") {
      ... on com_example_myproject_Animal {
        data {
          description {
            images {
              style {
                name
                aspectRatio
                filter
              }
            }
          }
        }
      }
    }
  }
}
----

You can extract the properties that you specified in your `styles.xml` previously:

.The result of fetching image styles
[source,json]
----
{
  "data": {
    "guillotine": {
      "query": [
        {
          "data": {
            "description": {
              "images": [
                {
                  "style": {
                    "name": "editor-style-grayscale",
                    "aspectRatio": null,
                    "filter": "hsbcolorize(0x000000); grayscale(); border(6, 0x000000)"
                  }
                }
              ]
            }
          }
        }
      ]
    }
  }
}
----

== Macros

Macros enable you to insert rich components into your text. When the page is rendered, the macro call is resolved and replaced. When the macro is resolved, it will either add text to your page or styles or scripts. See the https://developer.enonic.com/docs/xp/stable/cms/macros[macro reference docs] for a more in-depth explanation of how this works. In this section, we'll install a macro from an external application (_{macro-app}_), and look at how to use it. We'll also see how macros behave in a headless context.

=== Task: Install and use the {macro-app} package

The {macro-app} package comes with a set of macros that let you put text differently colored items with icons.

.The {macro-app} in action
image::macros-panel-macros.jpg["The Panel Macros package in action, showing differently colored panels." , width=600]

To use these macros, we first need to install the {macro-app}.

. Navigate to the Applications page (via the XP menu).
. Press "Install"
. Search for and install the "{macro-app}" app.
. Edit your site ({p1-site-name}). In the applications dropdown, find {macro-app}, and add it.
. Save and exit.

To add a macro to your HtmlArea, the easiest (and recommended) way is to use the macro tool.

Open up an {content-type-2} and try it out! The below example will use the "reindeer" created earlier.

. In the "Description" field, click the "insert macro" tool.
. Select one of the panels. If you have no preference, try the "Info panel".
. Add a header and some text to it. For reindeer, try:
+
.Reindeer macro data
Header:: Habitats
Text:: Reindeer are native to Arctic, sub-Arctic, tundra, boreal, and mountainous regions of northern Europe, Siberia, and North America.

+

.The insert macro form with reindeer data
image::macros-insert-macro.png["A form with 'header' and 'description' fields. Used to set macro parameters.", width=800]
. Try out the preview and see your macro in action
+
.The macro preview function
image::macros-preview-macro.png["The text we specified in the macro preview form inside a light blue box with an icon attached", width=800]

For more information on macros, including how to create your very own macros, refer back to https://developer.enonic.com/docs/xp/stable/cms/macros[the macro reference docs] from before.

=== Headless: Macros in headless contexts

In headless contexts, you don't get macros fully rendered. Instead, XP inserts `<editor-macro>` elements into the output of the HtmlArea. Each `<editor-macro>` has a `data-macro-ref` attribute that contains a unique reference. Use this reference to match it up with the macro data.

NOTE: When working headlessly, macros contain only data and _not_ any form of markup. In other words: the client needs to construct the markup and styling itself. Thus, the preview you see in Content Studio does not reflect what you get in a headless context. You would have to implement the markup and styling yourself.

Let's try and fetch the macro you just added to your {content-type-2}:

.Query that fetches all macro info from an HtmlArea
[source,GraphQL,{subs}]
----
{
  guillotine {
    query(contentTypes:"{project-name-full}:{content-type-2}",
      query: "displayName = 'Reindeer'") {
      ... on {project-name-query}_{content-type-2-capitalized} {
        data {
          description {
            processedHtml
            macrosAsJson
          }
        }
      }
    }
  }
}
----

.Macro query result
[source,json]
----
{
  "data": {
    "guillotine": {
      "query": [
        {
          "data": {
            "description": { <--.-->
              "processedHtml": "<p><editor-macro data-macro-name=\"info\" data-macro-ref=\"b226bdbb-a781-44e8-9402-dfc5d086af41\">Reindeer are native to Arctic, sub-Arctic, tundra, boreal, and mountainous regions of northern Europe, Siberia, and North America.</editor-macro></p>\n",
              "macrosAsJson": [ <--.-->
                {
                  "ref": "b226bdbb-a781-44e8-9402-dfc5d086af41",
                  "name": "info",
                  "descriptor": "com.enonic.app.panelmacros:info",
                  "config": {
                    "info": {
                      "body": "Reindeer are native to Arctic, sub-Arctic, tundra, boreal, and mountainous regions of northern Europe, Siberia, and North America.",
                      "header": "Habitats"
                    }
                  }
                }
              ]
            }
          }
        }
      ]
    }
  }
}
----

<.> The description now contains `<editor-macro>` tags in its `processedHtml` property.
<.> Using the `macrosAsJson` property, you can get the type and content of the macros.

== Next

We've looked at using simple input types to create content, but what if we want to do something more advanced? Next up: advanced content types, where we'll learn about grouping inputs together.
